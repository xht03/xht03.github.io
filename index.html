<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xht03.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="延绪的水上书">
<meta property="og:url" content="http://xht03.github.io/index.html">
<meta property="og:site_name" content="延绪的水上书">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xht03">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xht03.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>延绪的水上书</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">延绪的水上书</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/11/06/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/06/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">平摊分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-06 21:35:31 / 修改时间：21:36:13" itemprop="dateCreated datePublished" datetime="2024-11-06T21:35:31+08:00">2024-11-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/11/06/%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/11/06/平摊分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/11/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">二叉搜索树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-05 21:04:39" itemprop="dateCreated datePublished" datetime="2024-11-05T21:04:39+08:00">2024-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 15:55:04" itemprop="dateModified" datetime="2024-11-06T15:55:04+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/11/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/11/05/二叉搜索树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><strong>二叉搜索树（Binary Search Tree，BST）</strong>是一种特殊的二叉树，它具有以下性质：</p>
<ul>
<li><p><strong>有序性</strong>：对于树中的任意节点，其左子树上所有节点的值都小于该节点的值，其右子树上所有节点的值都大于该节点的值。</p>
</li>
<li><p><strong>二叉树结构</strong>：每个节点最多有两个子节点，即左子节点和右子节点。</p>
</li>
<li><p><strong>没有键值重复</strong>：树中不存在两个节点具有相同的键值。</p>
</li>
</ul>
<hr>
<p>二叉搜索树的基本操作包括：</p>
<ul>
<li><strong>查找（Search）</strong>：给定一个值，查找树中是否存在该值。</li>
<li><strong>插入（Insert）</strong>：插入一个新的值。</li>
<li><strong>删除（Delete）</strong>：删除树中的一个节点。</li>
<li><strong>遍历（Walk）</strong>：二叉搜索树可以通过中序遍历得到一个有序的元素序列。</li>
</ul>
<blockquote>
<p><strong>二叉搜索树上的基本操作所花费的时间与这棵树的高度 h 成正比。</strong></p>
</blockquote>
<hr>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>二叉搜索树性质允许我们通过一个简单的递归算法来<strong>按序输出</strong>二叉搜索树中的所有关键字，这种算法称为<strong>中序遍历（inorder tree walk）</strong>算法。</p>
<blockquote>
<p>这样命名的原因是输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。（前序遍历、后序遍历类似。）</p>
</blockquote>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line">	if x != NIL</span><br><span class="line">    	INORDER-TREE-WALK(x.left)</span><br><span class="line">        print x.key</span><br><span class="line">        INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure>

<p>显然，遍历一个二叉搜索树的时间代价是 **&Theta;(n)**。</p>
<hr>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><blockquote>
<p>在一棵高度为h 的二叉搜索树上，查询操作 <code>SEARCH</code>、<code>MINIMUM</code>、<code>MAXIMUM</code>、<code>SUCCESSOR</code> 和 <code>PREDECESSOR</code> 均可以在 <strong>O(h)</strong> 时间内完成。</p>
</blockquote>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>我们通过 <code>TREE-SEARCH(x, k)</code>，查找以<code>x</code>为根的树中是否包含关键字 <code>k</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x, k)</span><br><span class="line">	if x==NIL or k==x.key</span><br><span class="line">		return x</span><br><span class="line"></span><br><span class="line">	if k &lt; x.key</span><br><span class="line">		return TREE-SEARCH(x.left, k)</span><br><span class="line"></span><br><span class="line">	else return TREE-SEARCH(x.right, k)</span><br></pre></td></tr></table></figure>

<p>不难证明，查找操作的时间代价是 **O(h)**。</p>
<hr>
<h4 id="最小值和最大值"><a href="#最小值和最大值" class="headerlink" title="最小值和最大值"></a>最小值和最大值</h4><p><code>TREE-MINIMUM(x)</code>寻找以x为根的树中的<strong>最小值</strong>（就是子树的最左节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MINIMUM(x)</span><br><span class="line">	while x.left != NIL</span><br><span class="line">		x = x.left</span><br><span class="line">	return x</span><br></pre></td></tr></table></figure>

<p><code>TREE-MAXIMUM(x)</code>寻找以x为根的树中的<strong>最大值</strong>（就是子树的最右节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TREE-MAXIMUM(x)</span><br><span class="line">	while x.right != NIL</span><br><span class="line">		x = x.right</span><br><span class="line">	return x</span><br></pre></td></tr></table></figure>

<p>这两个过程在一棵高度为 h 的树上均能在 <strong>O(h)</strong> 时间内执行完。</p>
<hr>
<h4 id="后继和前驱"><a href="#后继和前驱" class="headerlink" title="后继和前驱"></a>后继和前驱</h4><p><strong>所谓后继，就是当前节点在中序遍历过程中的下一个节点</strong>。这也是从小到大排序中，大于当前节点的最小节点。</p>
<p><strong>前驱</strong>同理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 实现</span></span><br><span class="line"><span class="comment"># 寻找后继步骤：</span></span><br><span class="line"><span class="comment"># 1. 如果有右子树，后继是右子树中的最小节点</span></span><br><span class="line"><span class="comment"># 2. 如果没有，后继是当前节点的某个祖先节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_successor</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="comment"># 如果有右子树</span></span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> find_min(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果没有右子树</span></span><br><span class="line">    parent = node.parent</span><br><span class="line">    <span class="keyword">while</span> parent <span class="keyword">and</span> node == parent.right:</span><br><span class="line">        node = parent</span><br><span class="line">        parent = parent.parent</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_min</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">while</span> node.left:</span><br><span class="line">        node = node.left</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 实现</span></span><br><span class="line"><span class="comment"># 二叉树节点定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>

<p>该过程或者遵从一条简单路径沿树向上或者遵从简单路径沿树向下。所以，<code>SUCCESSOR</code> 操作可以在 <strong>O(h)</strong> 时间内完成。</p>
<hr>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入操作，与查找操作类似，只不过是在二叉搜索树中没能找到对应元素。此时，我们就<strong>在查找路径的尽头，插入新元素</strong>。</p>
<p>所以，<code>TREE-INSERT</code> 操作可以在 <strong>O(h)</strong> 时间内完成。</p>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, z)</span><br><span class="line">	y = NIL</span><br><span class="line">	x = T.root</span><br><span class="line"></span><br><span class="line">	while x != NIL</span><br><span class="line">		y = x</span><br><span class="line">		if z.key &lt; x.key</span><br><span class="line">			x = x.left</span><br><span class="line">		else</span><br><span class="line">			x = x.right</span><br><span class="line"></span><br><span class="line">	z.parent = y</span><br><span class="line"></span><br><span class="line">	if y == NIL</span><br><span class="line">		T.root = z  </span><br><span class="line">	else if z.key &lt; y.key</span><br><span class="line">	    y.left = z</span><br><span class="line">	else</span><br><span class="line">	    y.right = z</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除的过程如下：</p>
<ul>
<li>如果被删除节点 z 没有孩子，则直接删除 z。</li>
<li>如果 z 只有一个孩子，那么 z 孩子替代 z 的位置。</li>
<li>如果 z 有两个孩子：<ul>
<li>z 的后继 y（一定在 z 的右子树中）替代 z 的位置。</li>
<li>y 的孩子代替 y 的位置。（y 是子树中的最左节点，只有一个孩子。）</li>
</ul>
</li>
</ul>
<p><img src="https://ref.xht03.online/202411061545789.png"></p>
<p>不难证明，<code>TREE-DELETE</code> 能在 <strong>O(h)</strong> 时间内完成。</p>
<hr>
<h3 id="随机构建"><a href="#随机构建" class="headerlink" title="随机构建"></a>随机构建</h3><p><strong>随机构建二叉搜索树</strong>是指：按随机次序插入关键字到一棵初始的空树中而生成的树，且输入的关键字排列等可能的出现。</p>
<blockquote>
<p>一棵有 n 个不同关键字的<strong>随机构建二叉搜索树</strong>的期望高度为 **O(lgn)**。</p>
</blockquote>
<p><strong>证明</strong>：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/31/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/31/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-31 10:12:12" itemprop="dateCreated datePublished" datetime="2024-10-31T10:12:12+08:00">2024-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 22:08:04" itemprop="dateModified" datetime="2024-11-06T22:08:04+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/31/%E7%BA%A2%E9%BB%91%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/31/红黑树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p>
<ol>
<li>每个结点或是红色的，或是黑色的。</li>
<li>根结点是黑色的。</li>
<li>每个叶结点（NIL） 是黑色的。</li>
<li>如果一个结点是红色的，则它的两个子结点都是黑色的。</li>
<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。</li>
</ol>
<blockquote>
<p>图片例子</p>
</blockquote>
<hr>
<blockquote>
<p>一棵有 n 个内部结点的红黑树的高度至多为 **2·lg(n+1)**。</p>
</blockquote>
<blockquote>
<p>proof</p>
</blockquote>
<hr>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>由此可知：**红黑树的高度是 O(lgn)**。再结合二叉搜索树的性质，我们可知：红黑树的查询操作（<code>SEARCH</code>、<code>MINMUN</code>、<code>MAXIMUM</code>、<code>SUCESSOR</code>）均是 **O(lgn)**。</p>
<hr>
<h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><blockquote>
<p>图片</p>
</blockquote>
<hr>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol>
<li><p><strong>插入新节点</strong>：使用二叉搜索树的 <code>TREE_INSERT</code> 方法插入新节点，并将其颜色设为<strong>红色</strong>（可能会违反性质4，还需调整）。</p>
</li>
<li><p>调整树以恢复红黑性质：<strong>检查父节点颜色</strong>。</p>
<ul>
<li><p>如果新节点的父节点是<strong>黑色</strong>的，则树仍然是平衡的，不需要调整。</p>
</li>
<li><p>如果父节点是<strong>红色</strong>，则需要进一步<strong>检查叔叔节点</strong>：</p>
<ul>
<li><p>如果新节点的叔叔节点<strong>存在且为红色</strong>：</p>
<p>将父节点和叔叔节点都涂成黑色，并将祖父节点涂成红色，然后从祖父节点重新开始调整过程（递归调用）。</p>
</li>
<li><p>如果叔叔节点是<strong>黑色或为空</strong>：</p>
<p>根据新节点和父节点相对于祖父节点的位置，进行以下旋转之一：</p>
<ul>
<li><strong>左左情况（LL）</strong>：新节点是其父节点的左孩子，且父节点是祖父节点的左孩子。进行右旋转，然后交换祖父节点和父节点的颜色。</li>
<li><strong>右右情况（RR）</strong>：新节点是其父节点的右孩子，且父节点是祖父节点的右孩子。进行左旋转，然后交换祖父节点和父节点的颜色。</li>
<li><strong>左右情况（LR）</strong>：新节点是其父节点的左孩子，但父节点是祖父节点的右孩子。首先对父节点进行左旋转，将新节点变为左左情况，然后进行右旋转并交换颜色。</li>
<li><strong>右左情况（RL）</strong>：新节点是其父节点的右孩子，但父节点是祖父节点的左孩子。首先对父节点进行右旋转，将新节点变为右右情况，然后进行左旋转并交换颜色。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>根节点颜色调整</strong>：如果新节点成为根节点（即原根节点是红色），则将其颜色改为黑色，以满足根节点必须是黑色的性质。</p>
</li>
<li><p><strong>递归结束条件</strong>：当新节点变为黑色或成为根节点时，算法结束。</p>
</li>
</ol>
<blockquote>
<p>旋转图片 P182</p>
</blockquote>
<hr>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/18/%E6%95%A3%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/18/%E6%95%A3%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">散列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-18 10:55:56" itemprop="dateCreated datePublished" datetime="2024-10-18T10:55:56+08:00">2024-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-05 21:03:56" itemprop="dateModified" datetime="2024-11-05T21:03:56+08:00">2024-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/18/%E6%95%A3%E5%88%97%E8%A1%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/18/散列表/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><strong>散列表（Hash Table）</strong>，也称为哈希表，是一种通过哈希函数将<strong>键（Key）</strong>映射到表中一个位置以便快速访问记录的数据结构。它的主要目的是提供快速的数据<strong>插入</strong>、<strong>删除</strong>和<strong>查找</strong>操作。散列表通常由数组支持，这个数组称为“<strong>槽</strong>”或“<strong>桶</strong>”，数组的每个位置对应一个可能的哈希值。</p>
<blockquote>
<p>大量键值对存储时：</p>
<ul>
<li>如果使用<strong>数组</strong>，并使用键作为索引，则当键的取值范围很广，但键值对数量却不多时：需要开辟很大的数组空间，却只有很少数空间被使用，造成空间浪费。</li>
<li>所以，我们希望通过<strong>hash function</strong>将原本稀疏散落在数组各处的键值对，通过函数映射，集中存放在一个更小的空间中，提高空间利用率。</li>
</ul>
</blockquote>
<hr>
<p>散列表的基本操作包括：</p>
<ol>
<li><strong>插入（Insert）</strong>：将一个新的键值对插入到散列表中。</li>
<li><strong>查找（Search）</strong>：通过给定的键快速找到对应的值。</li>
<li><strong>删除（Delete）</strong>：从散列表中删除一个键值对。</li>
</ol>
<hr>
<p>散列表的工作原理如下：</p>
<ol>
<li><strong>哈希函数（Hash Function）</strong>：选择一个合适的哈希函数，它能够将输入的键（可以是任意数据类型）转换为数组索引。一个好的哈希函数应该能够均匀地将键分布在数组的索引上，以减少冲突。</li>
<li><strong>冲突解决（Collision Resolution）</strong>：由于不同的键可能会映射到同一个索引上，这种情况称为冲突。解决冲突的方法有：<ul>
<li><strong>链地址法（Chaining）</strong>：每个数组索引处都有一个链表，所有映射到该索引的键值对都存储在这个链表中。</li>
<li><strong>开放寻址法（Open Addressing）</strong>：如果发生冲突，寻找表中的另一个空闲位置来存储该键值对。常见的开放寻址策略有线性探测、二次探测和双重散列。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>在<strong>链地址法（chaining）</strong>中，每个数组索引（或称为“槽”或“桶”）都关联一个<strong>链表</strong>，所有映射到该索引的元素都会被存储在这个链表中。</p>
<p><img src="https://ref.xht03.online/202410181126836.png" alt="链地址法"></p>
<hr>
<p>链地址法的<strong>插入</strong>、<strong>查找</strong>、<strong>删除</strong>操作的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHAINED-HASH-INSERT(T ,x)</span><br><span class="line">	insert x at the head of list T[h(x. key)]</span><br><span class="line"></span><br><span class="line">CHAINED-HASH-SEARCH(T,k)</span><br><span class="line">	search for an element with key in list T[h(k)]</span><br><span class="line"></span><br><span class="line">CHAINED-HASH-DELETE(T,x)</span><br><span class="line">	delete x from the list T[h(x.key)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>给定一个能存放 n 个元素的、具有 m 个槽位的散列表 T。定义 T 的<strong>装载因子（load factor）</strong> &alpha; 为n&#x2F;m，即：一个链的平均存储元素数。</p>
</blockquote>
<ul>
<li><p><strong>插入操作</strong>：将新的元素链接到对应链表的头部，用时**O(1)**。</p>
</li>
<li><p><strong>删除操作</strong>：**如果是双向链表，用时O(1)**。如果是单向链表，用时与搜索操作时间相近。</p>
<blockquote>
<p>注意，这里删除操作<code>CHAINED-HASH-DELETE(T,x)</code>以元素 x 而不是它的关键字 k 作为输入，所以无需先搜索 x。</p>
</blockquote>
</li>
<li><p><strong>搜索操作</strong>：</p>
<blockquote>
<p>在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为 <strong>&Theta;(1 + &alpha;)</strong> 。</p>
</blockquote>
<p><strong>证明</strong>：如果查找的关键字 k 不在哈希表中，则需要首先找到对应槽的链表，再遍历整个链表，确定关键字 k 不在哈希表中。而链表的长度期望是 &alpha; 。所以总用时是：&Theta;(1 + &alpha;) 。</p>
<blockquote>
<p>在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次成功查找所需的平均时间为 <strong>&Theta;(1 + &alpha;)</strong> 。</p>
</blockquote>
<p><strong>证明</strong>：如果查找的关键字 k 在哈希表中，则需要先找到对应槽的链表，再搜索该链表。链表期望长度是 &alpha; ，关键字 k 等可能地出现在链表第1、2、……、&alpha; 个位置。所以总用时是：&Theta;(1 + (1+&alpha;)&#x2F;2) &#x3D; &Theta;(1 + &alpha;) 。</p>
</li>
</ul>
<p><strong>综上，当n、m数量级相近时，即n&#x3D;O(m)时：链地址法的所有字典操作均是 O(1) 时间。</strong></p>
<hr>
<p>python代码实现大致如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLLNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size=<span class="number">10</span></span>):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [<span class="literal">None</span>] * self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % self.size</span><br></pre></td></tr></table></figure>



<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>在<strong>开放寻址法(open addressing)</strong> 中，所有的元素都存放在散列表里。这里既没有链表，也没有元素存放在散列表外。因此在开放寻址法中，散列表可能会被填满，且<strong>装载因子 &alpha; 不超过1</strong>。</p>
<hr>
<h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><p>两个不同的键被哈希函数映射到同一个索引时，开放寻址法会再寻找新的空位索引，直至找到，再存放新插入的键值对。</p>
<p>插入操作伪代码如下：</p>
<blockquote>
<p><code>HASH-INSERT(T,x)</code>将元素 x 插入到哈希表 T 中。</p>
<p>如果第一次 hash 后的位置冲突了，则会再做第2、3……次 hash，直至找到空位用以插入新元素。所以**开放寻址法的 hash 函数需要两个参数：关键字 k 和第几次 i **。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HASH-INSERT(T,x)</span><br><span class="line">	i=0</span><br><span class="line">	repeat</span><br><span class="line">		j=h(x.key,i)</span><br><span class="line">		if T[j]==NIL</span><br><span class="line">			T[j]=x</span><br><span class="line">			return j</span><br><span class="line">		else i=i+1</span><br><span class="line">	until i==m</span><br><span class="line">	error &quot;hash table overflow&quot;</span><br></pre></td></tr></table></figure>

<p>常见探查方法，也即是对应的哈希函数有：</p>
<ul>
<li><p><strong>线性探查</strong>：</p>
<p>当发生冲突时，通过按顺序查找下一个空闲位置来存储键值对。</p>
<p><img src="https://ref.xht03.online/202410211202794.png" alt="i=0、1、……、m-1"></p>
<blockquote>
<p>线性探查方法比较容易实现，但它存在着一个问题（<strong>群集现象</strong>）：</p>
<p>当一个空槽前有 i 个满的槽时，该空槽为下一个将被占用的概率是 (i+1)&#x2F;m。连续被占用的槽就会变得越来越长，因而平均查找时间也会越来越大。</p>
<p><strong>随着连续被占用的槽不断增加，平均查找时间也随之不断增加。</strong></p>
</blockquote>
</li>
<li><p><strong>二次探查</strong>：</p>
<p>为了减轻线性探查的群集现象，我们每次往后推移二次函数个位置，进行探查。</p>
<p><img src="https://ref.xht03.online/202410211208734.png"></p>
</li>
<li><p><strong>双重散列</strong>：</p>
<p>双重散列通过两个不同的哈希函数来计算候选位置。</p>
<p><img src="https://ref.xht03.online/202410211213292.png"></p>
</li>
</ul>
<hr>
<h5 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h5><p>查找操作与插入操作类似。</p>
<p>查找操作伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HASH_SEARCH(T,k)</span><br><span class="line">	i=0</span><br><span class="line">	repeat</span><br><span class="line">		j=h(k,j)</span><br><span class="line">		if T[j]==k</span><br><span class="line">			return j</span><br><span class="line">		i=i+1</span><br><span class="line">	until T[j]==NIL or i==m</span><br><span class="line">	return NIL</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><p>采用开放寻址法时，删除操作是难以实现的。</p>
<p>例如：在插入关键字 k 时，发现槽 i 被占用了，则 k 就被插入到后面的位置上。此时我们欲将槽 i 中的关键字删除，那么就无法检索到关键字 k 了。</p>
<p>所以，删除操作不能直接删除，置为NIL，而是：删除后需要将槽标记为DELETED。</p>
<p>为此，<strong>在必须具备删除操作的情形下，一般不采用开放寻址法，而采用链地址法</strong>。</p>
<hr>
<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><blockquote>
<p>给定一个装载因子为 &alpha;&#x3D;n&#x2F;m &lt; 1 的开放寻址散列表，并假设是均匀散列的，则对于一次<strong>不成功的查找</strong>，其期望的探查次数至多为 <strong>1&#x2F;(1 - &alpha;)</strong> 。</p>
</blockquote>
<p><strong>证明</strong>：</p>
<p>对于一个不成功的探查，我们假设经历了 X 次探查。</p>
<p>对于第 i 次探查，如果是空位，则我们知道散列表中没有该关键字，否则还需要继续探查。</p>
<p>现在有 n 个元素和 m 个槽。</p>
<p><img src="https://ref.xht03.online/202410211348878.png"></p>
<p><img src="https://ref.xht03.online/202410211350873.png"></p>
<blockquote>
<p>对于一个装载因子为 &alpha; &lt; 1 的开放寻址散列表，假设采用均匀散列，且表中的每个关键字被查找的可能性是相同的，一次<strong>成功查找</strong>中的探查期望数至多为 <strong>1&#x2F;&alpha; · ln(1&#x2F;(1-&alpha;))</strong> 。</p>
</blockquote>
<p><strong>证明</strong>：</p>
<p>查找操作中所遍历的位置序列，与插入该关键字 k 时所遍历的位置序列是相同的。</p>
<p>假设 k 是第 i+1 个插入的关键字，则由上一定理，k 的探查的期望次数至多为 <strong>m&#x2F;(m-i)</strong> 。</p>
<p>对散列表中所有 n 个关键字求平均，则得到一次成功查找的探查期望次数为：</p>
<p><img src="https://ref.xht03.online/202410211402163.png"></p>
<hr>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数将<strong>关键字</strong>所组成的域到<strong>散列表索引</strong>所组成的域。</p>
<p>一个好的哈希函数应（近似地）满足<strong>简单均匀散列</strong>假设：每个关键字都被等可能地散列 m 个槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。</p>
<p>此外，哈希函数的某些情况可能会要求比简单均匀散列更强的性质。例如，可能希望某些很近似的关键字具有截然不同的散列值。</p>
<hr>
<h4 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h4><p>通过取 k 除以 m 的余数，将关键字 k 映射到 m 个槽中的某一个上。</p>
<p><img src="https://ref.xht03.online/202410211411505.png"></p>
<p>当应用除法散列法时，要避免选择 m 的某些值。例如，<strong>m 不应为 2 的幂</strong>，因为如果 m&#x3D;2<sup>p</sup>，则 h(k) 就是 k 的 p 个最低位数字。</p>
<p><strong>一个不太接近 2 的整数幂的素数，常常是 m 的一个较好的选择</strong>。</p>
<hr>
<h4 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h4><p>乘法散列法分两步：</p>
<ul>
<li><p>用关键字 k 乘上常数 A (0&lt;A&lt;1)，并提取 kA 的小数部分。</p>
</li>
<li><p>用 m 乘以这个值，再向下取整。</p>
</li>
</ul>
<p><img src="https://ref.xht03.online/202410211418100.png"></p>
<p>乘法散列法的一个优点是：<strong>对 m 的选择不是特别关键</strong>，一般选择它为 2 的某个幂次(m&#x3D;2<sup>p</sup>, p为某个整数）。这是因为如此在计算机上容易表示。</p>
<p>虽然这个方法对任何的A 值都适用，但对某些值效果更好（如：黄金分割比例倒数）。</p>
<hr>
<h4 id="全域散列法"><a href="#全域散列法" class="headerlink" title="全域散列法"></a>全域散列法</h4><p>一般情况下，哈希函数能将随机的输入均匀的映射到散列表的各个槽中。</p>
<p>但是如果有人恶意针对某个固定的哈希函数，故意输入n个关键字，被哈希函数映射到同一个槽中，那么平均检索时间退化为 &Theta;(n) 。</p>
<p>为了避免这种困境，我们将<strong>随机地选择哈希函数</strong>。这种方法称为：<strong>全域散列（universal hashing）</strong>。</p>
<hr>
<p>当然，随机选择并不是乱选，而是从一组预先设计（<strong>全域的</strong>）的函数 H 中，随机地选择一个哈希函数 h。</p>
<blockquote>
<p>设 H 为一组有限的散列函数，它们将关键字全域 U 映射到 {0, 1, …, m-1} 中。如果它们对每一对不同的关键字 k，l &isin; U，满足 h(k) &#x3D; h(l) 的散列函数 h &isin; H 的个数至多为 |H|&#x2F;m，那么这组函数 H 称为<strong>全域的（universal）</strong>。</p>
</blockquote>
<p>这表明了两点性质：</p>
<ul>
<li>如果从 H 中随机地选择一个散列函数，当关键字 k &ne; l 时，两者发生冲突的概率不大于 1&#x2F;m。</li>
<li>这也正好是从集合{0, 1, …, m-1} 中独立地随机选择 h(k) 和 h(l) 时发生冲突的概率。</li>
</ul>
<hr>
<p>我们可以证明，全域散列法能均匀地将关键字映射进各个槽中。</p>
<blockquote>
<p>如果 h 选自一组全域散列函数，将 n 个关键字散列到一个大小为 m 的表 T 中，并用链接法解决冲突。</p>
<ul>
<li>如果关键字 k 不在表中，则 k 被散列到的链表的期望长度 E[n<sub>h(k)</sub>] 至多为 <strong>&alpha; &#x3D; n&#x2F;m</strong>。</li>
<li>如果关键字 k 在表中，则包含关键字 k 的链表的期望长度 E[n<sub>h(k)</sub>] 至多为 **1+ &alpha;**。</li>
</ul>
</blockquote>
<p><strong>证明</strong>：</p>
<p>由于上述的性质1，我们知道：对于每一个关键字 k，其余关键字与之冲突的概率 &le; 1&#x2F;m。所以与 k 映射到同一个槽的关键字个数的期望为：n&#x2F;m &#x3D; &alpha;。</p>
<ul>
<li>如果关键字 k 不在表中，则 k 被散列到的链表的期望长度至多为 <strong>&alpha; &#x3D; n&#x2F;m</strong>。</li>
<li>如果关键字 k 在表中，则计数时需要算上 k，所以再 +1。</li>
</ul>
<hr>
<p>如何设计一组全域哈希函数呢？</p>
<ol>
<li><p>选择一个足够大的素数 p，使得每一个可能的关键字 k 都落在 [0, p-1] 。</p>
</li>
<li><p><img src="https://ref.xht03.online/202411052010570.png"></p>
</li>
</ol>
<hr>
<h3 id="完全散列"><a href="#完全散列" class="headerlink" title="完全散列"></a>完全散列</h3><p>当关键字集合是<strong>静态（static）</strong>时，散列技术也能提供出色的<strong>最坏情况</strong>性能。所谓静态，就是指一旦各关键字存入表中，关键字集合就不再变化了。</p>
<p>针对这一情形，我们采用：<strong>完全散列（perfect hashing）</strong>。</p>
<blockquote>
<p>如果该方法进行查找时，能在最坏情况下用 <strong>O(1)</strong> 时间完成。</p>
</blockquote>
<hr>
<p>我们采用<strong>两级</strong>的散列方法来设计完全散列方案，在每级上都使用<strong>全域散列</strong>。</p>
<ul>
<li>第一级与<strong>链地址法</strong>相同：从一组全域哈希函数中选出一个函数 h，将 n 个关键字映射到 m 个槽中。</li>
<li>第二级中，我们建立一个<strong>较小的散列表</strong>。<ul>
<li>通过选取合适的哈希函数 h<sub>i</sub>，保证第二级散列表上不会发生冲突。（<em>从一组全域哈希函数中随机选，如果冲突，则随机再选，直到选出。</em>）</li>
<li><strong>第二级散列表 S<sub>i</sub> 的大小 m<sub>i</sub> 总是被散列到槽中的元素个数 n<sub>i</sub> 的平方</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://ref.xht03.online/202411052028049.png" alt="完全散列表"></p>
<hr>
<p>我们可以证明：<strong>在第二级散列表选取哈希函数时，比较容易选出一个哈希函数，不存在冲突。</strong></p>
<blockquote>
<p>如果从一个全域散列函数类中随机选出散列函数 h，将 n 个关键宇存储在一个大小为 m &#x3D; n<sup>2</sup> 的散列表中，那么表中出现的冲突个数的期望小于 1&#x2F;2。</p>
</blockquote>
<p><img src="https://ref.xht03.online/202411052049766.png"></p>
<hr>
<p>此外，我们可以证明：<strong>通过合适地选取第一级哈希函数，预期使用的总空间大小为 O(n)。</strong></p>
<p><img src="/2024/10/18/%E6%95%A3%E5%88%97%E8%A1%A8/Users\Keats\AppData\Roaming\Typora\typora-user-images\image-20241105205626057.png" alt="image-20241105205626057"></p>
<hr>
<p>python 代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> isprime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全域线性哈希函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_hash</span>(<span class="params">a, b, p, m, key</span>):</span><br><span class="line">    <span class="keyword">return</span> (a * key + b) % p % m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubHashTable</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;子散列表&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sub_keys=[]</span>):</span><br><span class="line">        self.n = <span class="built_in">len</span>(sub_keys)</span><br><span class="line">        self.m = <span class="built_in">len</span>(sub_keys) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取大于maxVal的最小素数</span></span><br><span class="line">        maxVal = <span class="built_in">max</span>(sub_keys) <span class="keyword">if</span> <span class="built_in">len</span>(sub_keys) != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        maxVal = <span class="built_in">max</span>(maxVal, self.m)</span><br><span class="line">        self.p = maxVal + maxVal % <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> isprime(self.p):</span><br><span class="line">            self.p += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充键值, 保证不冲突</span></span><br><span class="line">        is_conflict = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> is_conflict:</span><br><span class="line">            is_conflict = <span class="literal">False</span></span><br><span class="line">            self.nums = [<span class="literal">None</span>] * self.m</span><br><span class="line">            self.a = random.randint(<span class="number">1</span>, self.p - <span class="number">1</span>)</span><br><span class="line">            self.b = random.randint(<span class="number">0</span>, self.p - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历子键, 填充哈希表</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> sub_keys:</span><br><span class="line">                idx = uni_hash(self.a, self.b, self.p, self.m, key)</span><br><span class="line">                <span class="keyword">if</span> self.nums[idx] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    is_conflict = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                self.nums[idx] = key</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 插入键值, 并重建哈希表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> self.search(key):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        subkeys = [k <span class="keyword">for</span> k <span class="keyword">in</span> self.nums <span class="keyword">if</span> k <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">        subkeys.append(key)</span><br><span class="line">        self.__init__(subkeys)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除键值, 并重建哈希表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        subkeys = [k <span class="keyword">for</span> k <span class="keyword">in</span> self.nums <span class="keyword">if</span> k <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> k != key]</span><br><span class="line">        self.__init__(subkeys)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> self.n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        idx = uni_hash(self.a, self.b, self.p, self.m, key)</span><br><span class="line">        <span class="keyword">return</span> self.nums[idx] == key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerfectHashTable</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;完全散列&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, m=<span class="number">10</span></span>):</span><br><span class="line">        self.m = m</span><br><span class="line">        self.sub_table = [SubHashTable()] * m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key</span>):</span><br><span class="line">        idx = key % self.m</span><br><span class="line">        self.sub_table[idx].insert(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        idx = key % self.m</span><br><span class="line">        self.sub_table[idx].delete(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, key</span>):</span><br><span class="line">        idx = key % self.m</span><br><span class="line">        <span class="keyword">return</span> self.sub_table[idx].search(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试功能是否有效</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pht = PerfectHashTable()</span><br><span class="line">    ref_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        key = random.randint(<span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line">        ref_set.add(key)</span><br><span class="line">        pht.insert(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ref_set:</span><br><span class="line">        <span class="keyword">assert</span> pht.search(key) == <span class="literal">True</span></span><br><span class="line">        pht.delete(key)</span><br><span class="line">        <span class="keyword">assert</span> pht.search(key) == <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All tests passed.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/11/%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/11/%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/" class="post-title-link" itemprop="url">顺序统计量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-11 15:56:45" itemprop="dateCreated datePublished" datetime="2024-10-11T15:56:45+08:00">2024-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-07 08:51:33" itemprop="dateModified" datetime="2024-11-07T08:51:33+08:00">2024-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/11/%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/11/顺序统计量/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="最小值和最大值"><a href="#最小值和最大值" class="headerlink" title="最小值和最大值"></a>最小值和最大值</h3><blockquote>
<p>在一个有 n 个元素的集合中，需要做多少次比较才能确定其最小元素呢？</p>
</blockquote>
<p>最简单的方式：依次遍历集合中的每个元素，并记录下当前最小元素。这样会经过 <strong>n-1</strong> 次比较。进一步，如果我们希望同时找到最小值和最大值，如此方法则需要 <strong>2n-2</strong> 次比较。</p>
<hr>
<p>但事实上，我们有更快速的方法，能同时找到最大值和最小值，且只需要 <strong>3[n&#x2F;2]</strong> 次比较。</p>
<p>步骤如下：</p>
<ul>
<li>将输入元素<strong>成对处理</strong>。对于每一对元素 a 和 b，相互比较。</li>
<li>将 a、b 中的较小者与当前最小值比较，将较大者与当前最大值比较。这样，每对元素需要3次比较。</li>
</ul>
<hr>
<p>在此基础上，比较次数可以进一步缩减到 **O(logn)**。</p>
<p>步骤如下：</p>
<ul>
<li><strong>递归处理</strong>：每次能将最大值、最小值所在集合的范围缩小一半。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_min_max</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># 如果数组为空，返回None</span></span><br><span class="line"></span><br><span class="line">    min_val = max_val = arr[<span class="number">0</span>]</span><br><span class="line">    start = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> start &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        <span class="comment"># 如果数组长度是奇数，最后一个元素与当前最小值和最大值比较</span></span><br><span class="line">        <span class="keyword">if</span> start % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> start &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>:</span><br><span class="line">                a, b = arr[start], arr[start + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a, b = arr[start], arr[start]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a, b = arr[start], arr[start + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较两个元素</span></span><br><span class="line">        <span class="keyword">if</span> a &lt; b:</span><br><span class="line">            <span class="keyword">if</span> a &lt; min_val:</span><br><span class="line">                min_val = a</span><br><span class="line">            <span class="keyword">if</span> b &gt; max_val:</span><br><span class="line">                max_val = b</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> b &lt; min_val:</span><br><span class="line">                min_val = b</span><br><span class="line">            <span class="keyword">if</span> a &gt; max_val:</span><br><span class="line">                max_val = a</span><br><span class="line"></span><br><span class="line">        start += <span class="number">2</span>  <span class="comment"># 移动到下一对元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_val, max_val</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">arr = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">10</span>]</span><br><span class="line">min_val, max_val = find_min_max(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Minimum is&quot;</span>, min_val)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Maximum is&quot;</span>, m)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h3><blockquote>
<p>在一个有 n 个元素的集合中，如何找到第 i 小的元素呢？</p>
</blockquote>
<h4 id="期望为线性时间的选择算法"><a href="#期望为线性时间的选择算法" class="headerlink" title="期望为线性时间的选择算法"></a>期望为线性时间的选择算法</h4><p><code>RANDOMIZED-SELECT</code> 是一个分治算法，用于在数组中找到第 <code>i</code> 小的元素。这个算法是基于快速排序的分区操作 <code>RANDOMIZED-PARTITION</code> 的，但它只递归地处理分区的一边，而不是两边。这使得 <code>RANDOMIZED-SELECT</code> 的期望运行时间为 **O(n)**，这比快速排序的 O(n · log n) 要好。</p>
<hr>
<p>步骤如下：</p>
<ol>
<li><strong>边界检查</strong>：如果子数组的范围 <code>p</code> 和 <code>r</code> 相等，说明已经找到了第 <code>i</code> 小的元素，直接返回。</li>
<li><strong>随机分区</strong>：使用 <code>RANDOMIZED-PARTITION</code> 对数组 <code>A[p..r]</code> 进行分区，返回分区的基准索引 <code>q</code>。</li>
<li><strong>计算基准位置</strong>：计算枢轴元素相对于子数组起始位置 <code>p</code> 的位置 <code>k</code>。</li>
<li>**比较 <code>i</code> 和 <code>k</code>**：如果 <code>i</code> 等于 <code>k</code>，则枢轴元素就是第 <code>i</code> 小的元素，返回 <code>A[q]</code>。如果 <code>i</code> 小于 <code>k</code>，则在左子数组 <code>A[p..q-1]</code> 中递归寻找第 <code>i</code> 小的元素。否则，在右子数组 <code>A[q+1..r]</code> 中递归寻找第 <code>i-k</code> 小的元素。</li>
</ol>
<hr>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-SELECT (A, p, r, i)</span><br><span class="line">	if p==r</span><br><span class="line">		return A[p]</span><br><span class="line">	q = RANDOMliZED-PARTITION(A, p, r)</span><br><span class="line">	k = q-p+1</span><br><span class="line">	if i == k</span><br><span class="line">		return A[q]</span><br><span class="line">	else if i&lt;k</span><br><span class="line">		return RANOOMIZED-SELECT(A, p, q-1, i)</span><br><span class="line">	else return RANOOMIZED-SELECT(A, q+l, r, i-k)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="最坏情况为线性时间的选择算法"><a href="#最坏情况为线性时间的选择算法" class="headerlink" title="最坏情况为线性时间的选择算法"></a>最坏情况为线性时间的选择算法</h4><blockquote>
<p>因为随机选可能很倒霉</p>
</blockquote>
<p>我们给出一个选择算法 <code>SELECT</code>，最坏情况仍为线性时间。</p>
<p>步骤如下：</p>
<ol>
<li><strong>分组</strong>：将数组分为大约 <code>n/5</code> 组，每组包含5个元素。如果有剩余元素（即 <code>n % 5</code> 不为0），则形成最后一组。</li>
<li><strong>寻找每组的中位数</strong>：对每组进行插入排序（或其他线性时间排序），然后选择每组的中位数。</li>
<li><strong>递归寻找中位数的中位数</strong>：对所有组的中位数进行递归调用 <code>SELECT</code> 算法，找到它们的中位数 <code>x</code>。</li>
<li><strong>划分数组</strong>：使用 <code>x</code> 作为主元，<code>X</code> 是区间里第 <code>k</code> 小的元素，对整个数组进行划分。划分后，数组被分为低区（元素小于 <code>x</code>）、中区（元素等于 <code>x</code>）和高区（元素大于 <code>x</code>）。</li>
<li><strong>递归选择</strong>：根据 <code>i</code> 的值，决定是在低区、中区还是高区递归调用 <code>SELECT</code> 算法：<ul>
<li>如果 <code>i</code> 等于 <code>k</code>（<code>x</code> 在数组中的位置），则返回 <code>x</code>。</li>
<li>如果 <code>i</code> 小于 <code>k</code>，则在低区递归调用 <code>SELECT</code>。</li>
<li>如果 <code>i</code> 大于 <code>k</code>，则在高区递归调用 <code>SELECT</code>，且 <code>i = i-k</code>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>图片</p>
</blockquote>
<hr>
<p>我们下面分析该算法的运行时间，证明：其在最坏情况下，运行时间仍为 **O(n)**。</p>
<blockquote>
<p>证明</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/11/Scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/11/Scheduler/" class="post-title-link" itemprop="url">Scheduler</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-11 09:45:03 / 修改时间：09:45:35" itemprop="dateCreated datePublished" datetime="2024-10-11T09:45:03+08:00">2024-10-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/11/Scheduler/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/11/Scheduler/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">堆排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-06 10:51:36" itemprop="dateCreated datePublished" datetime="2024-10-06T10:51:36+08:00">2024-10-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 13:57:39" itemprop="dateModified" datetime="2024-11-06T13:57:39+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/06/堆排序/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一个<strong>数组</strong>，存储在数组中的二叉树。堆可以看成一个近似的<strong>完全二叉树</strong>，除了最底层外，该树是充满的。</p>
<p>堆可以分为两类：</p>
<ul>
<li><strong>最大堆</strong>：父节点 &gt; 子节点</li>
<li><strong>最小堆</strong>：父节点 &lt; 子节点</li>
</ul>
<p><img src="/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\堆排序\heap.png" alt="最大堆"></p>
<hr>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的时间复杂度也是 <strong>O(n·lgn)<strong>。但是，不同于归并排序，堆排序具有</strong>空间原址性</strong>：只需要常数个额外空间来存储临时数据。</p>
<p>为了实现堆，我们要实现以下两个函数：</p>
<ul>
<li><code>MAX-HEAPIFY()</code>：最大堆化函数，时间复杂度 **O(lgn)**。</li>
<li><code>BUILD-MAX-HEAP()</code>：建立最大堆函数，时间复杂度 **O(n)**。</li>
</ul>
<hr>
<h4 id="堆化"><a href="#堆化" class="headerlink" title="堆化"></a>堆化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码</span></span><br><span class="line"><span class="comment"># A: List of elements in the heap</span></span><br><span class="line"><span class="comment"># i: Index of the element to check</span></span><br><span class="line"><span class="comment"># n: Total number of elements in the heap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_heapify</span>(<span class="params">A, i, n</span>):</span><br><span class="line">    largest = i  <span class="comment"># Initialize largest as root</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># i&#x27;s left child</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># i&#x27;s right child</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If left child is larger than root</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> A[left] &gt; A[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If right child is larger than the largest so far</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> A[right] &gt; A[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If largest is not root</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        A[i], A[largest] = A[largest], A[i]  <span class="comment"># Swap</span></span><br><span class="line">        max_heapify(A, largest, n)  <span class="comment"># Recursively heapify the affected sub-tree</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\堆排序\max-heapify.png" alt="最大堆化的调用过程（以i=2为例）"></p>
<p>需要注意：当对 i 节点调用<code>MAX-HEAPIFY()</code>时，只有当其左右子树都是最大堆时，调用后，i 节点开始的树才是最大堆。</p>
<p>直观上，不难发现<code>MAX-HEAPIFY()</code>的时间复杂度是：**O(lgn)**。</p>
<hr>
<h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_max_heap</span>(<span class="params">A</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    A.heap_size = n  <span class="comment"># Set the heap size</span></span><br><span class="line">    <span class="comment"># Start from the last non-leaf node and move upwards</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        max_heapify(A, i, n)</span><br></pre></td></tr></table></figure>

<p>粗略的看，每次调用<code>max_heapify()</code>函数的时间开销是**O(lgn)<strong>，总共调用了</strong>O(n)<strong>次，所以<code>build_max_heap()</code>的时间复杂度应该是：</strong>O(n·lgn)**。</p>
<p>但是由于：底层节点调用<code>max_heapify()</code>的时间复杂度实际上是**O(h)<strong>，远远小于</strong>O(n)<strong>，且底层节点数量更多，时间开销接近</strong>O(lgn)<strong>的高层节点数量很少。所以，<code>build-max-heap()</code>的时间复杂度比</strong>O(n·lgn)<strong>更小，是</strong>O(n)**。</p>
<p>推导如下：</p>
<blockquote>
<p>高度为h的节点最多有 [n&#x2F;2<sup>h+1</sup>] 个。</p>
</blockquote>
<p><img src="/2024/10/06/%E5%A0%86%E6%8E%92%E5%BA%8F/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\堆排序\overhead.png"></p>
<p>因此，我们可以在<strong>线性时间</strong>内，把一个无序数组构造成为一个最大堆。</p>
<hr>
<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序的过程：</p>
<ul>
<li>在整个数组上<strong>建立最大堆</strong>。</li>
<li>数组的第一个元素（待排序序列中的最大元素），与待排序序列的最后一个元素交换。</li>
<li>堆大小（也是待排序序列长度）减1。</li>
<li>对堆顶元素（数组第一个元素）调用<code>max_heapify</code>函数，保证新的堆仍是最大堆。</li>
<li>如此，排好了原序列中的最大元素，且新序列仍是最大堆。如此循环即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapsort</span>(<span class="params">A</span>):</span><br><span class="line">    build_max_heap(A)  <span class="comment"># Build the max heap</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A), <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        A[<span class="number">0</span>], A[i-<span class="number">1</span>] = A[i-<span class="number">1</span>], A[<span class="number">0</span>]  <span class="comment"># Swap the root with the last element</span></span><br><span class="line">        A.heap_size -= <span class="number">1</span>  <span class="comment"># Decrease the heap size</span></span><br><span class="line">        max_heapify(A, <span class="number">0</span>, i-<span class="number">1</span>)  <span class="comment"># Heapify the root</span></span><br></pre></td></tr></table></figure>

<p>堆排序的时间复杂度：**O(n·lgn)**。</p>
<p><img src="https://ref.xht03.online/202411060917722.png"></p>
<hr>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列是一种数据结构，维护由一组元素，支持插入和删除最大元素（或最小元素）。</p>
<p>一个<strong>最大优先队列</strong>支持以下操作：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述</th>
<th align="center">时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INSERT(S,x)</td>
<td align="center">把元素 x 插入集合 S 中。</td>
<td align="center"><strong>O(lgn)</strong></td>
</tr>
<tr>
<td align="center">MAXIMUM(S)</td>
<td align="center">返回 S 中具有最大元素。</td>
<td align="center"><strong>O(1)</strong></td>
</tr>
<tr>
<td align="center">EXTRACT-MAX(S)</td>
<td align="center">去掉并返回 S 中的具有最大元素。</td>
<td align="center"><strong>O(lgn)</strong></td>
</tr>
<tr>
<td align="center">INCREASE-KEY(S, x, k)</td>
<td align="center">将元素 x 增加到 k（假设k&gt;x）</td>
<td align="center"><strong>O(lgn)</strong></td>
</tr>
</tbody></table>
<p>需要注意：</p>
<ul>
<li>堆并不一定是是二叉堆，二叉堆只是常见且易于用数组实现而已。</li>
<li>最大堆（二叉堆）只是优先队列的一种实现方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python code</span></span><br><span class="line"><span class="comment">#（这里省略了class heap的类定义）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MAXIMUM(S)</span></span><br><span class="line"><span class="comment"># 返回堆顶元素即可</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_maximum</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="keyword">if</span> A.heap_size &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Heap is empty&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># EXTRACT-MAX(S)</span></span><br><span class="line"><span class="comment"># 返回并删除堆顶元素，再对堆顶元素调用max_heapify()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_extract_max</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="keyword">if</span> A.heap_size &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Heap underflow&quot;</span>)</span><br><span class="line">    max_value = A[<span class="number">0</span>]</span><br><span class="line">    A[<span class="number">0</span>] = A[A.heap_size - <span class="number">1</span>]</span><br><span class="line">    A.heap_size -= <span class="number">1</span></span><br><span class="line">    max_heapify(A, <span class="number">0</span>, A.heap_size)</span><br><span class="line">    <span class="keyword">return</span> max_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parent</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INCREASE-KEY(S, x, k)</span></span><br><span class="line"><span class="comment"># 将A[i]赋值为k，并往上逐个检查：是否大于父节点，若大于则交换。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_increase_key</span>(<span class="params">A, i, key</span>):</span><br><span class="line">    <span class="keyword">if</span> key &lt; A[i]:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;New key is smaller than current key&quot;</span>)</span><br><span class="line">    A[i] = key</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A[parent(i)] &lt; A[i]:</span><br><span class="line">        A[i], A[parent(i)] = A[parent(i)], A[i]  <span class="comment"># Swap with parent</span></span><br><span class="line">        i = parent(i)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># INSERT(S,x)</span></span><br><span class="line"><span class="comment"># 在堆末尾插入负无穷，再调用heap_increase_key()将负无穷变为x，从而实现插入。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_heap_insert</span>(<span class="params">A, key</span>):</span><br><span class="line">    A.heap_size += <span class="number">1</span></span><br><span class="line">    A[A.heap_size - <span class="number">1</span>] = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)  <span class="comment"># Set the new leaf node with a very small value</span></span><br><span class="line">    heap_increase_key(A, A.heap_size - <span class="number">1</span>, key)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">快速排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-05 09:22:39" itemprop="dateCreated datePublished" datetime="2024-10-05T09:22:39+08:00">2024-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 21:33:06" itemprop="dateModified" datetime="2024-11-06T21:33:06+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/05/快速排序/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序也是一种<strong>分治算法</strong>。</p>
<p>快速排序分为三步：</p>
<ol>
<li><strong>分解</strong>：数组 <code>A[p.. r]</code> 被划分为两个（可能为空）子数组 <code>A[p.. q-1]</code> 和 <code>A[q+ 1.. r]</code>。<ul>
<li><code>A[p .. q-1]</code> 中的每一个元素都小于等于 <code>A[q]</code>。</li>
<li><code>A[q]</code> 也小于等于 <code>A[q+1..r]</code> 中的每个元素。</li>
</ul>
</li>
<li><strong>解决</strong>：对划分出的两个子数组，分别递归调用快速排序。</li>
<li><strong>合并</strong>：由于子数组都是原址排序的，所以不需要合并操作。</li>
</ol>
<hr>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QUICKSORT(A, p, r)</span><br><span class="line">	if p &lt; r</span><br><span class="line">		q = PARTITION(A, p, r)</span><br><span class="line">		QUICKSORT(A, p, q-1)</span><br><span class="line">		QUICKSORT(A, q+1, r)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A, p, r)</span><br><span class="line">	x = A[r]</span><br><span class="line">	i = p—1</span><br><span class="line">	for j = p to r-1</span><br><span class="line">		if A[j] &lt;= x</span><br><span class="line">			i = i + 1</span><br><span class="line">			exchange A[i] with A[j]</span><br><span class="line">	exchange A[i+1] with A[r]</span><br><span class="line">	return i + 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图片</p>
</blockquote>
<hr>
<h3 id="快排性能"><a href="#快排性能" class="headerlink" title="快排性能"></a>快排性能</h3><h4 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h4><p>当划分产生的两个子问题分别包含了 n-1 个元素和 0 个元素时，快速排序的最坏情况发生了。</p>
<p>此时运行时间的递推公式为：</p>
<p><img src="https://ref.xht03.online/202411062113154.png"></p>
<p>我们通过归纳法，可以证明：<strong>最坏</strong>情况下，快速排序的运行时间为 **&Theta;(n<sup>2</sup>)**。</p>
<p>此外，当输入数组已经<strong>完全有序</strong>时，快速排序的时间复杂度仍然为 **&Theta;(n<sup>2</sup>)**。</p>
<hr>
<h4 id="最好情况"><a href="#最好情况" class="headerlink" title="最好情况"></a>最好情况</h4><p>在可能的最平衡的划分中，<code>PARTITION</code> 得到的两个子问题的规模都不大于 n&#x2F;2。</p>
<p>此时运行时间的递推公式为：</p>
<p><img src="https://ref.xht03.online/202411062118665.png"></p>
<p>我们通过主定理，可以证明：<strong>最好</strong>情况下，快速排序的运行时间为 **&Theta;(n · lgn)**。</p>
<hr>
<h4 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h4><p>快速排序的平均运行时间<strong>更接近于其最好情况，而非最坏情况</strong>。</p>
<p>我们举例说明：</p>
<blockquote>
<p>例子</p>
</blockquote>
<hr>
<h3 id="随机化的快排"><a href="#随机化的快排" class="headerlink" title="随机化的快排"></a>随机化的快排</h3><p>在讨论快速排序的平均情况性能的时候，我们的前提假设是：<strong>输入数据的所有排列都是等概率出现</strong>。但在现实中，这个假设并不总是成立的。所以对于一些输入，快排的最坏情况可能经常发生。</p>
<p>为了避免，我们引入随机化版本：<strong>每次划分时，随机选择基准（pivot）</strong>。</p>
<hr>
<p>伪代码如下：</p>
<blockquote>
<p>快排函数：几乎没有变化，只是将划分函数 <code>PARTITION</code> 替换为新的 <code>RANDOMIZED-PARTITION</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RANOOMIZED-QUICKSORT CA, p, r)</span><br><span class="line">	if p&lt;r</span><br><span class="line">		q = RANDOMIZED-PARTITION (A, p, r)</span><br><span class="line">	RANOOMIZED-QUICKSORT (A, p, q-1)</span><br><span class="line">	RANOOMIZED-QUICKSORT (A, q+1, r)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>划分函数：从子数组中随机选择基准</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOMIZED-PARTITION (A, p, r)</span><br><span class="line">	i = RANDOM(p, r)</span><br><span class="line">	exchange A[r] with A[i]</span><br><span class="line">	return PARTITION(A, p, r)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/10/01/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/01/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">随机算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-01 09:38:11" itemprop="dateCreated datePublished" datetime="2024-10-01T09:38:11+08:00">2024-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-06 13:57:35" itemprop="dateModified" datetime="2024-11-06T13:57:35+08:00">2024-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/10/01/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/10/01/随机算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p>对于一个算法，它的平均执行速度很快，但很可能存在一些特定的输入，使得算法效率很低。如果这样的输入经常出现，那么算法的实际执行效率就会低于期望的效率。为了避免这样的情况，我们常常采用<strong>随机算法</strong>。</p>
<p>不失一般性地，假设给定一个数组 A，包含元素 1~n，我们讨论如何构造 A 的随机排列。</p>
<blockquote>
<p>注意：我们让随机发生在算法上，而不是在输入分布上。</p>
</blockquote>
<hr>
<h3 id="Permute-By-Sorting"><a href="#Permute-By-Sorting" class="headerlink" title="Permute-By-Sorting"></a>Permute-By-Sorting</h3><p>一个通常的方法是：</p>
<ul>
<li>为数组的每个元素 A[i] 赋一个随机的优先级 P[i]，</li>
<li>然后依据优先级对数组 A 中的元素进行排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_array_by_priority</span>(<span class="params">A</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为数组的每个元素分配随机优先级</span></span><br><span class="line">    <span class="comment"># 元组列表，包含元素和随机优先级</span></span><br><span class="line">    P = [(v, random.random()) <span class="keyword">for</span> v <span class="keyword">in</span> A]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据优先级对数组元素进行排序</span></span><br><span class="line">    <span class="comment"># 根据元组的第二个元素（优先级）排序</span></span><br><span class="line">    P.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 根据排序后的优先级更新原数组 A</span></span><br><span class="line">    <span class="comment"># 只取排序后的元素值</span></span><br><span class="line">    A = [v <span class="keyword">for</span> v, p <span class="keyword">in</span> P]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">sorted_A = sort_array_by_priority(A)</span><br><span class="line"><span class="built_in">print</span>(sorted_A)</span><br></pre></td></tr></table></figure>

<p>这种随机算法的时间复杂度取决于排序算法的选择。如果采用的是归并、快排，那么时间复杂度可以达到 **O(n·lgn)**。</p>
<hr>
<h3 id="Randomize-in-Place"><a href="#Randomize-in-Place" class="headerlink" title="Randomize in Place"></a>Randomize in Place</h3><p>产生随机排列的更好方法是：<strong>原址排列给定数组</strong>。</p>
<p>过程如下：</p>
<ul>
<li>在进行第 i 次迭代时，元素 A[i] 是从元素A[i] 到 A[n] 中随机选取的。</li>
<li>且第 i 次迭代以后， A[i]不再改变。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">randomize_in_place</span>(<span class="params">A</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 生成从 i 到 n-1 的随机整数</span></span><br><span class="line">        j = random.randint(i, n-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 交换 A[i] 与 A[j]</span></span><br><span class="line">        A[i], A[j] = A[j], A[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">randomize_in_place(A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/09/22/Allocator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/22/Allocator/" class="post-title-link" itemprop="url">Allocator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-22 16:56:42" itemprop="dateCreated datePublished" datetime="2024-09-22T16:56:42+08:00">2024-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-23 22:29:22" itemprop="dateModified" datetime="2024-09-23T22:29:22+08:00">2024-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/09/22/Allocator/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/09/22/Allocator/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><h4 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h4><p>操作系统位于硬件和软件之间，为用户程序提供底层硬件资源的抽象。操作系统提供必要的<strong>系统调用（system calls）</strong>。从而，用户程序不必再考虑如何使用硬件，而是通过这些 <strong>system calls</strong> 来调用硬件资源。</p>
<p>![操作系统在计算机中的位置](Position of OS in A Computer System.png)</p>
<p>当我们编写 c 语言程序时，我们可以直接通过 <code>malloc()</code> 和 <code>free()</code> 函数，简洁地申请和释放内存空间。但是 <code>malloc()</code> 和 <code>free()</code> 实际上并没有申请内存的权限，而是请操作系统的<strong>内核（kernel）</strong>帮忙。<strong>kernel</strong> 将<code>malloc()</code>所需的内存分配好并给它。所以，真正负责分配内存空间的是内核的<strong>allocator（分配器）</strong>。</p>
<p><strong>allocator（分配器）</strong>是一种用于管理内存资源的机制。它负责在操作系统与应用程序之间调度和分配内存。内存分配器通常与动态内存管理有关，允许程序在运行时申请和释放内存。</p>
<p>具象的说：<strong>allocator就是负责内存分配的系统调用函数</strong>。</p>
<p>我们希望实现4个系统调用函数：</p>
<ul>
<li><code>void kinit()</code>：初始化内存空间</li>
<li><code>void* kalloc_page()</code>：分配新的页</li>
<li><code>void kfree_page(void* p)</code>：释放页</li>
<li><code>void* kalloc(unsigned long long size)</code>：分配指定大小的内存块</li>
<li><code>void kfree(void* ptr)</code>：释放指定的内存块</li>
</ul>
<blockquote>
<p>请注意<code>kfree()</code>、<code>kfree_page()</code>接口的隐含意义：在释放空间时，用户不需告知库这块空间的大小。因此，在只传入一个指针的情况下，<strong>allocator</strong>必须能够弄清楚这块内存的大小。</p>
</blockquote>
<hr>
<h4 id="Free-space-management"><a href="#Free-space-management" class="headerlink" title="Free-space management"></a>Free-space management</h4><ul>
<li><p>如果需要管理的空间被划分为固定大小的单元，就很容易。</p>
<blockquote>
<p>就像：内存空间按<strong>页（Page）</strong>划分，内存由若干页组成。一页通常为4KB（4096 bytes）。</p>
</blockquote>
</li>
<li><p>如果要管理的空闲空间由大小不同的单元构成，管理就变得困难而有趣。</p>
<blockquote>
<p>这种情况出现在：用户级的内存分配库，如<code>malloc()</code>和<code>free()</code>，或者操作系统用分段（segmentation）的方式实现虚拟内存。</p>
</blockquote>
</li>
</ul>
<p>对于第二种情况，出现了<strong>外部碎片（external fragmentation）</strong>的问题：空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</p>
<p>例如在下图中，全部可用空闲空间是60字节，但被切成两个20字节大小的碎片，导致一个25字节的分配请求失败。</p>
<p>我们主要关心的是<strong>外部碎片</strong>。但是，分配程序也可能有<strong>内部碎片（internal fragmentation）</strong>的问题。如果分配程序给出的内存块超出请求的大小，在这种块中超出请求的空间（因此而未使用）就被认为是内部碎片（因为浪费发生在已分配单元的内部），这是另一种形式的空间浪费。</p>
<p>但是，简单起见，这里主要考虑外部碎片。</p>
<p><img src="/2024/09/22/Allocator/fragmentation.png" alt="外部碎片&amp;内部碎片"></p>
<hr>
<h4 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism"></a>Mechanism</h4><p><strong>allocator</strong>管理的空间由于历史原因被称为<strong>堆（heap）</strong>，在堆上管理空闲空间的数据结构通常称为<strong>空闲列表（free list）</strong>。该结构包含了管理内存区域中所有空闲块的引用（也就是：地址）。当然，该数据结构不一定真的是列表，而只是某种可以追踪空闲空间的数据结构。</p>
<p>我们先<strong>以页为单位</strong>讨论。</p>
<p><code>freelist</code>本质上是一个指针，指向第一个空闲页的开始地址。每个空闲页开头存放一个指针<code>run</code>，指向下一个空闲页。最后一个空闲页的<code>run</code>指针指向<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空闲物理页节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲物理页的链表（的头节点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SpinLock lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span>* <span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>当<strong>allocator</strong>初始化时：allocator本应该将所有物理内存分页，存进<code>freelist</code>中。但是由于物理地址刚开始处存放着内核代码，所以allocator会<strong>把内核代码结束处以后的所有地址空间分页</strong>。</p>
<p><img src="/2024/09/22/Allocator/freelist.png" alt="free list"></p>
<p>当用户程序向<strong>allocator</strong>申请page时：<strong>allocator</strong>返回<code>freelist</code>，也就是将<code>freelist</code>指向的第一个page分配给它。然后<code>freelist = run1</code>，也就是使<code>freelist</code>指向下一个空闲页。如此，第一个页“page1”就被分配给用户程序了。需要注意的是：allocator不关心已分配的页，已分配的页由各个申请的用户程序管理。且已分配的页不用再维护<code>run</code>指针，所以整页都是可以使用的（只有空闲页才需要在页头写上<code>run</code>指针）。</p>
<p><img src="/2024/09/22/Allocator/allocated.png" alt="allocate a page"></p>
<p>当用户程序向<strong>allocator</strong>释放page时：allocator将返还的page添加到当前链表的第一个，也就是：<code>freelist</code>&#x3D;被释放的页的地址。然后：被释放页的<code>run</code>指针&#x3D;原先<code>freelist</code>的值。</p>
<p><img src="/2024/09/22/Allocator/free.png" alt="free a page"></p>
<hr>
<p>以上，我们都是以页为单位，讨论内存分配。但是申请的内存可能很小，远远不足一页。</p>
<p>最朴素的想法就是：我们需要把一页的内存，按不同大小需求，划分成不同小块。</p>
<ul>
<li><p><strong>已分配的内存块</strong>：</p>
<p>我们需要保证分配出去的内存能被回收。由于<code>void kfree(void* ptr)</code>函数参数只告诉了地址指针，并没有告诉大小。所以每个内存块需要存储其大小<code>size</code>和一些必要信息<code>magic</code>，即每个内存块都需要有一个<strong>头部（header）</strong>。如此，当<code>kfree()</code>时：我们读取<code>ptr</code>指向处的往前若干字节就能知道需要释放的内存空间。</p>
</li>
<li><p><strong>未分配的空间</strong>：</p>
<p>类似页于与页之间的<code>freelist</code>，我们也会在页内维护一个这样的<code>freelist</code>。</p>
</li>
</ul>
<p><img src="/2024/09/22/Allocator/pusu.png" alt="内存块结构"></p>
<p><img src="/2024/09/22/Allocator/figure.png" alt="一次分配后的页"></p>
<p>但是，如此分配内存空间后，即便使用过的内存块都被释放，<strong>空闲列表里也是一串串大小不一的内存碎片</strong>。而且它们在链表里的顺序是随机的，并不是按照地址从小到大排列的，由它们被用户程序释放的顺序所决定。</p>
<p>之所以会这样，是因为：我们忘了<strong>合并（coalesce）列表项</strong>，虽然整个内存空间是空闲的，但却被逐渐分成了小块，因此形成了碎片化的内存空间。</p>
<hr>
<p>事已至此，那如何在内存池（<code>freelist</code>中的空闲内存块）中找到符合要求的内存块呢？且我们希望能保证：<strong>快速</strong>和<strong>碎片最小化</strong>。</p>
<p>常见的内存分配算法：</p>
<ol>
<li><strong>首次适配（First-fit）</strong>：在内存池中找到第一个满足需求的空闲块并分配。</li>
<li><strong>最佳适配（Best-fit）</strong>：寻找最接近所需大小的空闲块进行分配，以减少剩余的空闲空间。</li>
<li><strong>最坏适配（Worst-fit）</strong>：选择最大的空闲块分配，保留较大的剩余空间。</li>
<li><strong>快速适配（Quick-fit）</strong>：预先分配若干种常用大小的内存块，减少分配和释放的时间。</li>
</ol>
<hr>
<h4 id="Segregated-list"><a href="#Segregated-list" class="headerlink" title="Segregated list"></a>Segregated list</h4><p>为了解决内存碎片化的问题，我们采用<strong>分离空闲列表（segregated list）</strong>，也就是：<strong>厚块分配程序（slab allocator）</strong>。</p>
<p>基本想法很简单：如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。</p>
<p>首先我们介绍基本概念：</p>
<ul>
<li><p><strong>Cache（缓存）</strong>：SLAB 分配器为特定类型的对象创建缓存，缓存包含多个对象，这些对象的大小是固定的。缓存是预分配的内存块的集合，便于频繁创建和销毁相同类型的对象。</p>
</li>
<li><p><strong>Slab（厚块）</strong>：Slab 是 cache 中的组成单元，每个 cache 包含多个 Slab。Slab 是一组预分配的内存块，包含了若干个固定大小的对象块（即 <strong>object</strong>），用于保存对象。一个 Slab 可以是空闲的、部分使用的或者完全使用的。Slab 通过内存池预先分配内存，以便快速提供给请求的对象。</p>
</li>
<li><p><strong>Object（对象）</strong>：分配器管理的最小内存单元或内存块，被称为 object。每个 object 是一块固定大小的内存，用来存储具体的数据结构或对象。通过 Slab allocator，内存被分配为一个个 Slab，而 Slab 中则由若干个相同大小的 object 组成。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_CACHE 10    <span class="comment">// 每个cache的对象大小：8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 厚块节点（25个字节）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Slab</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Slab</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span>* free_list;    <span class="comment">// 空闲对象的链表</span></span><br><span class="line">    usize free_count;     <span class="comment">// 空闲对象的数量</span></span><br><span class="line">    SpinLock lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厚块链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cache</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Slab</span>* <span class="title">slabs</span>;</span></span><br><span class="line">    usize slab_count; <span class="comment">// slab的数量</span></span><br><span class="line">    usize obj_size;   <span class="comment">// 每个对象的大小（划分成几个字节的块）</span></span><br><span class="line">&#125; cache[NUM_CACHE];</span><br></pre></td></tr></table></figure>

<p>具体来说：</p>
<ol>
<li>在内核启动时，它为可能频繁请求的内核对象创建一些<strong>缓存</strong>。这些的对象缓存每个分离了特定大小的空闲列表，因此能够很快地响应内存请求和释放。</li>
<li>如果某个缓存中的空闲空间快耗尽时，它就向通用内存分配程序申请一些<strong>内存厚块（slab）</strong>（总量是页大小和对象大小的公倍数）。</li>
<li>相反，如果给定厚块中对象的引用计数变为0，通用的内存分配程序可以从专门的分配程序中回收这些空间，这通常发生在虚拟内存系统需要更多的空间的时候。</li>
</ol>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/2024/09/22/Allocator/structure.png" alt="内存结构"></p>
<h4 id="kinit"><a href="#kinit" class="headerlink" title="kinit()"></a>kinit()</h4><p>初始化时，我们将始于<code>end</code>止于<code>PHYSTOP</code>的堆地址空间全部分页，并把他们连接到<code>kmem</code>结构体中的<code>freelist</code>。</p>
<p>注意：<code>end</code>是内核地址空间的终止处，但不一定是4KB的倍数。对于<code>end</code>所在页没有用完的部分，我们弃之不用。我们从大于<code>end</code>的最小的4KB倍数的地址处开始分页，直至物理地址终点处<code>PHYSTOP</code>。（所以上图中<code>end</code>和page1之间并不是直接相接的，可能有空余空间。）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kinit</span><span class="params">()</span> &#123;</span><br><span class="line">    init_rc(&amp;kalloc_page_cnt);</span><br><span class="line">    init_spinlock(&amp;kmem.lock);						<span class="comment">// 初始化自旋锁</span></span><br><span class="line">    freerange((<span class="type">void</span>*)K2P(end), (<span class="type">void</span>*)PHYSTOP);		<span class="comment">// 将堆划分成一页页</span></span><br><span class="line">    init_caches();									<span class="comment">// 初始化cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PAGE_SIZE-1) &amp; ~(PAGE_SIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PAGE_SIZE-1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指定区间的物理页（只有kinit时使用）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span>* pa_start, <span class="type">void</span>* pa_end)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="keyword">for</span>(p = (<span class="type">char</span>*)PGROUNDUP((usize)pa_start); p + PAGE_SIZE &lt;= (<span class="type">char</span>*)pa_end; p += PAGE_SIZE) &#123;</span><br><span class="line">        kfree_page(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="kalloc-page"><a href="#kalloc-page" class="headerlink" title="kalloc_page()"></a>kalloc_page()</h4><p>由于计算机可能是多核运行，可能同时多个进程申请空间。为了避免将同一页分配给多个进程，我们要加锁保持一致性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">kalloc_page</span><span class="params">()</span> &#123;</span><br><span class="line">    increment_rc(&amp;kalloc_page_cnt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    acquire_spinlock(&amp;kmem.lock);   <span class="comment">// 加锁</span></span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r) &#123;</span><br><span class="line">        kmem.freelist = r-&gt;next;    <span class="comment">// 从空闲链表中取出一个物理页r</span></span><br><span class="line">    &#125;</span><br><span class="line">    release_spinlock(&amp;kmem.lock);   <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// 没有空闲物理页</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="kfree-page"><a href="#kfree-page" class="headerlink" title="kfree_page()"></a>kfree_page()</h4><p>将指针<code>p</code>所指的页添加会页的空闲列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree_page</span><span class="params">(<span class="type">void</span>* p)</span> &#123;</span><br><span class="line">    decrement_rc(&amp;kalloc_page_cnt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((usize)p % PAGE_SIZE || (usize)p &lt; K2P(end) || (usize)p &gt;= PHYSTOP) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kfree_page fail: p = %p\n&quot;</span>, p);   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)p;</span><br><span class="line">    acquire_spinlock(&amp;kmem.lock);   <span class="comment">// 加锁</span></span><br><span class="line">    r-&gt;next = kmem.freelist;        <span class="comment">// 将释放的物理页加入空闲链表</span></span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release_spinlock(&amp;kmem.lock);   <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="slab-alloc"><a href="#slab-alloc" class="headerlink" title="slab_alloc()"></a>slab_alloc()</h4><p>给定<code>cache</code>，也就是给定对象大小，我们在一串串slab中寻找空闲对象，并返回其地址。如果<code>cache</code>中的所有slab都没有空闲对象，那么我们调用<code>kalloc_page()</code>申请新的页，并将其划分成新的slab，在返回新slab中的第一个对象的地址。</p>
<p>注意：</p>
<ul>
<li>当我们把新的一页划分后得到slab时，由于每个slab的开头需要存放<code>Slab</code>结构体（25字节，但是为了对齐需要32字节）在开头，所以剩下4064字节用于划分对象。对象大小并不一定总是能整除剩余空间大小，所以是有可能划分完所有对象后，存在碎片空间。</li>
<li>对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">slab_alloc</span><span class="params">(<span class="keyword">struct</span> Cache* cache)</span> &#123;</span><br><span class="line">    <span class="comment">//-------------------- 从已有的slab中分配对象 --------------------</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Slab</span>* <span class="title">slab</span> =</span> cache-&gt;slabs;</span><br><span class="line">    <span class="keyword">while</span> (slab != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        acquire_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (slab-&gt;free_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">void</span>* obj = slab-&gt;free_list;</span><br><span class="line">            slab-&gt;free_list = *(<span class="type">void</span>**)obj; <span class="comment">// 指向下一个空闲对象</span></span><br><span class="line">            slab-&gt;free_count--;</span><br><span class="line">            release_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        release_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">        slab = slab-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------- 如果所有slab都用完了，分配新的页 --------------------</span></span><br><span class="line">    slab = (<span class="keyword">struct</span> Slab*)kalloc_page();</span><br><span class="line">    <span class="keyword">if</span> (slab == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;slab_alloc: fail to get a new page\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------- 初始化新的slab --------------------</span></span><br><span class="line">    init_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">    acquire_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">    slab-&gt;next = cache-&gt;slabs;</span><br><span class="line">    cache-&gt;slabs = slab;</span><br><span class="line">    slab-&gt;free_list = (<span class="type">void</span>*)((<span class="type">char</span>*)slab + <span class="number">32</span>);   <span class="comment">// 留出空间给 struct Slab(25 bytes)</span></span><br><span class="line">    slab-&gt;free_count = (PAGE_SIZE - <span class="number">32</span>) / cache-&gt;obj_size;   <span class="comment">// 8是指针的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------- 初始化空闲对象链表 --------------------</span></span><br><span class="line">    <span class="type">char</span>* obj = (<span class="type">char</span>*)slab-&gt;free_list;</span><br><span class="line">    <span class="keyword">for</span>(usize i = <span class="number">1</span>; i &lt; slab-&gt;free_count; i++) &#123;</span><br><span class="line">        *(<span class="type">void</span>**)obj = obj + cache-&gt;obj_size;   <span class="comment">// 每一个对象的开始，存放下一个对象的地址</span></span><br><span class="line">        obj += cache-&gt;obj_size;</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="type">void</span>**)obj = <span class="literal">NULL</span>;</span><br><span class="line">    cache-&gt;slab_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------------------- 返回第一个空闲对象 --------------------</span></span><br><span class="line">    obj = slab-&gt;free_list;</span><br><span class="line">    slab-&gt;free_list = *(<span class="type">void</span>**)obj; <span class="comment">// 指向下一个空闲对象</span></span><br><span class="line">    slab-&gt;free_count--;</span><br><span class="line">    release_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="slab-free"><a href="#slab-free" class="headerlink" title="slab_free()"></a>slab_free()</h4><p>给出对象地址，我们将其添加会对应slab的空闲对象列表中。</p>
<p>注意：由于slab是由页划分得来的，所以slab的其实地址都是4KB的倍数。而且，每个slab的开始处存放着<code>struct Slab</code>结构体。所以我们只需要求出：小于<code>obj</code>的最大的4KB倍数（这就是该slab的<code>Slab</code>结构体地址）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="type">void</span>* obj)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Slab</span> *<span class="title">slab</span> =</span> (<span class="keyword">struct</span> Slab*)PGROUNDDOWN((usize)obj);</span><br><span class="line">    acquire_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">    *(<span class="type">void</span>**)obj = slab-&gt;free_list;</span><br><span class="line">    slab-&gt;free_list = obj;</span><br><span class="line">    slab-&gt;free_count++;</span><br><span class="line">    release_spinlock(&amp;slab-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc()"></a>kalloc()</h4><p>分配指定大小的内存块。我们通过调用<code>slab_alloc()</code>来分配适当大小的内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">kalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printk(&quot;CPU%lld kalloc: size = %lld\n&quot;, cpuid(), size);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; PAGE_SIZE) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kalloc: size too large\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 不支持大于一页的分配</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cache</span>* <span class="title">cache</span> =</span> get_cache(size);	<span class="comment">// 寻找object_size刚刚大于size的cache</span></span><br><span class="line">    <span class="keyword">if</span> (cache == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kalloc: no suitable cache for size %lld\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有合适的 cache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slab_alloc(cache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Cache* <span class="title function_">get_cache</span><span class="params">(usize size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_CACHE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= cache[i].obj_size) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;cache[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果没有合适的 cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="kfree"><a href="#kfree" class="headerlink" title="kfree()"></a>kfree()</h4><p>释放指定地址的内存块。我们直接通过调用<code>slab_free()</code>把内存块添加会空闲对象列表，这样这个内存块就再被其他程序申请使用了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">void</span>* ptr)</span> &#123;</span><br><span class="line">    slab_free(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[教材OSTEP第17章：空闲空间管理](<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces (wisc.edu)</a>)</p>
<p><a target="_blank" rel="noopener" href="https://github.com/mit-pdos/xv6-public">MIT的xv6操作系统</a></p>
<p><a target="_blank" rel="noopener" href="https://osh.fducslg.com/operating-systems-h-24fall">FDU2024操作系统 (H)：Lab1</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xht03</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xht03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://book-written-on-water.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

    </div>
</body>
</html>
