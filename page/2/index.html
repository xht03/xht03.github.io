<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xht03.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="延绪的水上书">
<meta property="og:url" content="http://xht03.github.io/page/2/index.html">
<meta property="og:site_name" content="延绪的水上书">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xht03">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xht03.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>延绪的水上书</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">延绪的水上书</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/09/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-18 13:24:28" itemprop="dateCreated datePublished" datetime="2024-09-18T13:24:28+08:00">2024-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-07 09:02:57" itemprop="dateModified" datetime="2024-11-07T09:02:57+08:00">2024-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/09/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/09/18/动态规划/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>动态规划（dynamic programming）</strong>与分治方法相似，都是通过组合子问题的解来求解原问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。</p>
<ul>
<li>分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。</li>
<li>与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。</li>
</ul>
<p>所以形象地说：<strong>动态规划是有记忆的分治</strong>。</p>
<hr>
<p>动态规划方法通常用来求解<strong>最优化问题(optimization problem)</strong> 。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。可能有多个解都达到最优值。</p>
<p>具体来说，动态规划问题一般具有一下两个性质：</p>
<ul>
<li><strong>最优子结构</strong>：一个问题的最优解包含其子问题的最优解。</li>
<li><strong>重叠子问题</strong>：问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子间题，而不是一直生成新的子问题。</li>
</ul>
<hr>
<p>我们通常按如下 4 个步骤来设计一个动态规划算法：</p>
<ol>
<li><strong>刻画</strong>最优解的<strong>结构</strong>。</li>
<li>给出最优解的值的<strong>递推公式</strong>。</li>
<li><strong>自底向上</strong>地计算最优解的值。</li>
<li>利用计算出的信息<strong>构造</strong>一个最优解。</li>
</ol>
<p>步骤 1~3 是动态规划算法求解问题的基础。</p>
<ul>
<li>如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤 4 。</li>
<li>如果需要一个最优解, 有时就需要在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。</li>
</ul>
<p>所以形象地说：<strong>动态规划就是一种“数学归纳法”</strong>。</p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>如果使用一般的分治算法（递归），会有大量的重复计算。以下图为例，计算 F<sub>6</sub> 的递归过程中 F<sub>3</sub> &#x3D; F<sub>2</sub> + F<sub>1</sub> 被重复进行了 3 次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://ref.xht03.online/202411070901377.png"></p>
<p>动态规划算法为了避免重复的子问题计算，把每次计算过的子问题的解都记录下来，以后在遇到相同子问题时，直接“背答案”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_dp</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage:</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Fibonacci number at position <span class="subst">&#123;n&#125;</span> is: <span class="subst">&#123;fibonacci_dp(n)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h4><p><strong>问题描述</strong>：</p>
<p>给定一段长度为 n 英寸的钢条和一个价格表 p<sub>i</sub> (i &#x3D; l, 2, …, n)。求切割钢条方案，使得销售收益 r 最大。注意：如果长度为 n 英寸的钢条的价格 P<sub>n</sub> 足够大，最优解可能就是完全不需要切割。</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">价格</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
<td align="center">17</td>
<td align="center">17</td>
<td align="center">20</td>
<td align="center">24</td>
<td align="center">30</td>
</tr>
</tbody></table>
<p><strong>解决办法</strong>：</p>
<p>首先我们将这个问题描述数学化。</p>
<p>如果一个最优解将钢条切割为 k 段（0 &lt; k &lt; n+1）, 那么最优切割方案：</p>
<p><img src="https://ref.xht03.online/202411070901994.png"></p>
<p>将钢条切割为长度分别为 i<sub>1</sub>, i<sub>2</sub>, …, i<sub>k</sub> 的小段，得到最大收益：</p>
<p><img src="https://ref.xht03.online/202411070901856.png"></p>
<p>考虑给出 r<sub>n</sub> 的递推公式。</p>
<p>切割的第一刀，可以切在任何位置。且如果是最优解，则切后的两段钢条的切割方案也一定是最优解。</p>
<p><img src="https://ref.xht03.online/202411070901060.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cut_rod</span>(<span class="params">p, n</span>):</span><br><span class="line">    <span class="comment"># p 是价格列表，n 是钢条的长度</span></span><br><span class="line">    r = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        max_val = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, j + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 计算切割后的最大收益</span></span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val, p[i] + r[j - i])</span><br><span class="line">        r[j] = <span class="built_in">max</span>(max_val, p[j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 价格表 &amp; 钢条长度</span></span><br><span class="line">prices = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>]</span><br><span class="line">length = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算最大收益</span></span><br><span class="line">max_profit = cut_rod(prices, length)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最大收益为: <span class="subst">&#123;max_profit&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h4><p><strong>问题描述</strong>：</p>
<p>给定一个 n 个矩阵的序列（矩阵链）&lt;A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub> &gt;，且矩阵 A<sub>i</sub> 的规模为 p<sub>i-1</sub> *p<sub>i</sub> 。求完全括号化方案（使用结合律加括号），使乘积 A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> 所需标量乘法次数最少。</p>
<p><img src="https://ref.xht03.online/202411070902314.png"></p>
<p><strong>解决办法</strong>：</p>
<p>首先：用子问题的最优解来递归地定义原问题最优解。</p>
<p>对矩阵链乘法问题，我们可以这么定义子问题：</p>
<ul>
<li><p>对所有 1 &lt;&#x3D; i &lt;&#x3D; j &lt;&#x3D; n ，确定 &lt;A<sub>i</sub>, A<sub>i+1</sub>, …, A<sub>j</sub> &gt; 的最小代价括化方案。</p>
</li>
<li><p>令 <code>m[i, j]</code> 表示计算矩阵 A<sub>i</sub> A<sub>i+1</sub> … A<sub>j</sub> 所需标量乘法次数的最小值，那么，原问题的最优解计算 A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> 所需的最低代价就是<code>m[1, n]</code>。</p>
</li>
</ul>
<p>然后不难得出<code>m[i, j]</code>的递推公式：</p>
<p><img src="https://ref.xht03.online/202411070902053.png"></p>
<p><code>m[i, j] </code> 的值给出了子问题最优解，但它并未提供足够的信息来构造最优解。为此，我们用 <code>s[i, j]</code> 保存 A<sub>i</sub> A<sub>i+1</sub> … A<sub>j</sub> 最优括号化方案的分割点位置k。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">matrix_chain_order</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="comment"># 矩阵的数量，p 是矩阵的维度列表</span></span><br><span class="line">    <span class="comment"># 创建一个二维数组 m，其中 m[i][j] 表示计算矩阵 Ai...Aj 的乘积所需的最小标量乘法次数</span></span><br><span class="line">    <span class="comment"># 创建一个二维数组 s，其中 s[i][j] 存储计算 m[i][j] 时最优分割点 k 的位置</span></span><br><span class="line">    n = <span class="built_in">len</span>(p) - <span class="number">1</span></span><br><span class="line">    m = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    s = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按链的长度 l 进行处理，l 从 2 到 n</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">            j = i + l - <span class="number">1</span></span><br><span class="line">            m[i][j] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                <span class="comment"># q 表示 Ai...Ak 和 Ak+1...Aj 的乘积所需的标量乘法次数</span></span><br><span class="line">                q = m[i][k] + m[k+<span class="number">1</span>][j] + p[i] * p[k+<span class="number">1</span>] * p[j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> q &lt; m[i][j]:</span><br><span class="line">                    m[i][j] = q</span><br><span class="line">                    s[i][j] = k</span><br><span class="line">    <span class="keyword">return</span> m, s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_optimal_parens</span>(<span class="params">s, i, j</span>):</span><br><span class="line">    <span class="keyword">if</span> i == j:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;A<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;(&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        print_optimal_parens(s, i, s[i][j])</span><br><span class="line">        print_optimal_parens(s, s[i][j] + <span class="number">1</span>, j)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;)&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的维度列表，例如：30*35、35*15、15*5、5*10、10*20、20*25</span></span><br><span class="line">p = [<span class="number">30</span>, <span class="number">35</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br><span class="line">m, s = matrix_chain_order(p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最少的标量乘法次数是:&quot;</span>, m[<span class="number">0</span>][<span class="built_in">len</span>(p) - <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优乘法顺序是:&quot;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print_optimal_parens(s, <span class="number">0</span>, <span class="built_in">len</span>(p) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p><strong>问题描述</strong>：</p>
<p>给定两个序列 X &#x3D; &lt;x<sub>1</sub>, x<sub>2</sub>, …, x<sub>m</sub>&gt; 和 Y &#x3D; &lt;y<sub>1</sub>, y<sub>2</sub>, …, y<sub>n</sub>&gt;，求 X 和 Y 最长的公共子序列。</p>
<p><strong>解决办法</strong>：</p>
<p>首先，观察到最长公共子序列的递归结构。</p>
<p><img src="https://ref.xht03.online/202411070902320.png"></p>
<p>我们定义 <code>c[i,j]</code> 表示 X<sub>i</sub> 和 Y<sub>j</sub> 的最长公共子序列的长度。</p>
<p>则不难得到递推公式：</p>
<p><img src="https://ref.xht03.online/202411070902421.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="comment"># 初始化矩阵</span></span><br><span class="line">    m = <span class="built_in">len</span>(X)</span><br><span class="line">    n = <span class="built_in">len</span>(Y)</span><br><span class="line">    c = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建c矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>]:</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c[i][j] = <span class="built_in">max</span>(c[i - <span class="number">1</span>][j], c[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从c矩阵回溯找到LCS</span></span><br><span class="line">    index = c[m][n]</span><br><span class="line">    lcs_seq = [<span class="string">&quot;&quot;</span>] * (index)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回溯找LCS</span></span><br><span class="line">    i, j = m, n</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> X[i - <span class="number">1</span>] == Y[j - <span class="number">1</span>]:</span><br><span class="line">            lcs_seq[index - <span class="number">1</span>] = X[i - <span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c[i - <span class="number">1</span>][j] &gt; c[i][j - <span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(lcs_seq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">X = <span class="string">&quot;ABCBDAB&quot;</span></span><br><span class="line">Y = <span class="string">&quot;BDCAB&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;LCS of <span class="subst">&#123;X&#125;</span> and <span class="subst">&#123;Y&#125;</span> is <span class="subst">&#123;lcs(X, Y)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/09/08/SSH%E4%B8%8EWSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/08/SSH%E4%B8%8EWSL/" class="post-title-link" itemprop="url">SSH指令&WSL安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-08 21:57:23" itemprop="dateCreated datePublished" datetime="2024-09-08T21:57:23+08:00">2024-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-10 00:21:41" itemprop="dateModified" datetime="2024-09-10T00:21:41+08:00">2024-09-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Missing-Semester/" itemprop="url" rel="index"><span itemprop="name">The Missing Semester</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/09/08/SSH%E4%B8%8EWSL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/09/08/SSH与WSL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SSH指令"><a href="#SSH指令" class="headerlink" title="SSH指令"></a>SSH指令</h3><h4 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h4><p><strong>SSH（Secure Shell）</strong>是一种网络协议，加密两台计算机之间的通信，并且支持各种身份验证机制。现实中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。</p>
<p>SSH 密钥登录采用的是<strong>非对称加密</strong>。非对称加密需要两个密钥成对使用，分为<strong>公钥（public key）</strong>和<strong>私钥（private key）</strong>。每个用户通过自己的密钥登录。其中，私钥必须私密保存，不能泄漏；公钥则是公开的，可以对外发送。它们的关系是，公钥和私钥是一一对应的，每一个私钥都有且仅有一个对应的公钥，反之亦然。</p>
<p>如果数据使用公钥加密，那么只有使用对应的私钥才能解密，其他密钥都不行；反过来，如果使用私钥加密（这个过程一般称为“签名”），也只有使用对应的公钥解密。</p>
<p>SSH 的软件架构是<strong>服务器-客户端模式（Server-Client）</strong>。在这个架构中，SSH 软件分成两个部分：</p>
<ul>
<li>向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 <code>ssh</code>。</li>
<li>接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 <code>sshd</code>。</li>
</ul>
<p>另外，OpenSSH 还提供一些辅助工具软件（比如 <code>ssh-keygen</code> 、<code>ssh-agent</code>）和专门的客户端工具（比如 <code>scp</code> 和 <code>sftp</code> ），这个教程也会予以介绍。</p>
<hr>
<h4 id="SSH客户端"><a href="#SSH客户端" class="headerlink" title="SSH客户端"></a>SSH客户端</h4><ul>
<li><p><strong>安装SSH客户端</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 和 Debian（Linux系统一般自带ssh）</span></span><br><span class="line">$ sudo apt install openssh-client</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>登录服务器</strong>：</p>
<p><code>hostname</code> 是主机名，它可以是域名，也可能是 IP 地址，或局域网内部的主机名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh hostname</span><br></pre></td></tr></table></figure>

<p>不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@hostname</span><br></pre></td></tr></table></figure>

<p>用户名也可以使用 <code>ssh</code> 的 <code>-l</code> 参数指定，这样的话，用户名和主机名就不用写在一起了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -l username host</span><br></pre></td></tr></table></figure>

<p>ssh 默认连接服务器的22端口，<code>-p</code>参数可以指定其他端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 8821 foo.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置文件</strong>：</p>
<blockquote>
<p> 配置文件的格式是：</p>
<ol>
<li>每一行是一个配置命令。每行都是配置项和对应的值，配置项的大小写不敏感，与值之间使用空格分隔。</li>
<li><code>#</code> 开头的行表示注释，<code>#</code> 只能放在一行的开头，不能放在一行的结尾。</li>
</ol>
</blockquote>
<p>SSH 客户端的<strong>全局配置文件</strong>是 <code>/etc/ssh/ssh_config</code>。</p>
<p><strong>用户个人的配置文件</strong>在<code>~/.ssh/config</code>，优先级高于全局配置文件。</p>
<p>除了配置文件，<code>~/.ssh</code>目录还有一些用户个人的密钥文件和其他文件。下面是其中一些常见的文件。</p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>~/.ssh/id_ecdsa</code></td>
<td align="left">用户的 ECDSA 私钥</td>
</tr>
<tr>
<td align="left"><code>~/.ssh/id_ecdsa.pub</code></td>
<td align="left">用户的 ECDSA 公钥</td>
</tr>
<tr>
<td align="left"><code>~/.ssh/id_rsa</code></td>
<td align="left"><strong>用于 SSH2 的 RSA 私钥</strong></td>
</tr>
<tr>
<td align="left"><code>~/.ssh/id_rsa.pub</code></td>
<td align="left"><strong>用于SSH2 的 RSA 公钥</strong></td>
</tr>
<tr>
<td align="left"><code>~/.ssh/identity</code></td>
<td align="left">用于 SSH1 的 RSA 私钥。</td>
</tr>
<tr>
<td align="left"><code>~/.ssh/identity.pub</code></td>
<td align="left">用于 SSH1 的 RSA 公钥</td>
</tr>
<tr>
<td align="left"><code>~/.ssh/known_hosts</code></td>
<td align="left">包含 SSH 服务器的公钥指纹</td>
</tr>
</tbody></table>
<p>用户个人的配置文件<code>~/.ssh/config</code>，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。下面是一个例子。（可以写入多个服务器信息。<code>*</code>是通配符，表示所有服务器。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Host GitHub</span><br><span class="line">  User git</span><br><span class="line">  Hostname github.com</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_keats</span><br><span class="line">  </span><br><span class="line">Host *</span><br><span class="line">  Port 2222</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_keats</span><br></pre></td></tr></table></figure>

<p>以后，登录 <code>remote.example.com</code> 时，只要执行 <code>ssh remoteserver</code> 命令，就会自动套用 config 文件里面指定的参数。</p>
</li>
</ul>
<hr>
<h4 id="SSH服务器"><a href="#SSH服务器" class="headerlink" title="SSH服务器"></a>SSH服务器</h4><ul>
<li><p><strong>安装SSH服务器</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动sshd</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">$ sudo systemctl start sshd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">$ sudo systemctl stop sshd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ sudo systemctl restart sshd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 sshd 在计算机下次启动时自动运行</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> sshd.service</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置文件</strong>：</p>
<p>sshd 的配置文件在 <code>/etc/ssh</code> 目录，主配置文件是 <code>sshd_config</code>，此外还有一些安装时生成的密钥。</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/ssh/sshd_config</code></td>
<td>配置文件</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_ecdsa_key</code></td>
<td>ECDSA 私钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_ecdsa_key.pub</code></td>
<td>ECDSA 公钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_key</code></td>
<td>用于 SSH1 的 RSA 私钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_key.pub</code></td>
<td>用于 SSH1 的 RSA 公钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_rsa_key</code></td>
<td>用于 SSH2 的 RSA 私钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_rsa_key.pub</code></td>
<td>用于 SSH2 的 RSA 公钥</td>
</tr>
<tr>
<td><code>/etc/pam.d/sshd</code></td>
<td>PAM 配置文件</td>
</tr>
</tbody></table>
<p>配置文件修改以后，并不会自动生效，必须重新启动 sshd。</p>
</li>
</ul>
<hr>
<h4 id="SSH密钥登录"><a href="#SSH密钥登录" class="headerlink" title="SSH密钥登录"></a>SSH密钥登录</h4><blockquote>
<p>SSH 密钥登录分为以下的步骤：</p>
<ol start="0">
<li>客户端通过 <code>ssh-keygen</code> 生成自己的公钥和私钥。</li>
<li>手动将客户端的公钥放入远程服务器的指定位置。</li>
<li>客户端向服务器发起 SSH 登录的请求。</li>
<li>服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</li>
<li>客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</li>
<li>服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</li>
</ol>
</blockquote>
<ul>
<li><p><strong>生成密钥</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接输入ssh-keygen，程序会询问一系列问题（直接回车即可），然后生成密钥。</span></span><br><span class="line">$ ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-t参数，指定密钥的加密算法。如果省略该参数，默认使用 RSA 算法。</span></span><br><span class="line">$ ssh-keygen -t dsa</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>上传公钥</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥以后，公钥必须上传到服务器，才能使用公钥登录。</span></span><br><span class="line"><span class="comment"># OpenSSH 规定，用户公钥保存在服务器的~/.ssh/authorized_keys文件。</span></span><br><span class="line"><span class="comment"># 你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的~/.ssh/authorized_keys文件。</span></span><br><span class="line"><span class="comment"># 只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了。每个公钥占据一行。如果该文件不存在，可以手动创建。</span></span><br><span class="line"><span class="comment"># 用户可以手动编辑该文件，把公钥粘贴进去；也可以在本机计算机上，执行ssh-copy-id 命令，自动上传公钥。</span></span><br><span class="line"><span class="comment"># 只要公钥上传到服务器，下次登录时，OpenSSH 就会自动采用密钥登录，不再提示输入密码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenSSH 自带一个ssh-copy-id命令，可以自动将公钥拷贝到远程服务器的~/.ssh/authorized_keys文件。</span></span><br><span class="line"><span class="comment"># 如果~/.ssh/authorized_keys文件不存在，ssh-copy-id命令会自动创建该文件。</span></span><br><span class="line"><span class="comment"># 公钥文件可以不指定路径和.pub后缀名，ssh-copy-id会自动在~/.ssh目录里面寻找。</span></span><br><span class="line"></span><br><span class="line">$ ssh-copy-id -i key_file user@host</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="WSL安装"><a href="#WSL安装" class="headerlink" title="WSL安装"></a>WSL安装</h3><h4 id="启用-Windows-功能："><a href="#启用-Windows-功能：" class="headerlink" title="启用 Windows 功能："></a>启用 Windows 功能：</h4><p><img src="/2024/09/08/SSH%E4%B8%8EWSL/function.png" alt="打卡虚拟机相关功能"></p>
<hr>
<h4 id="下载-WSL："><a href="#下载-WSL：" class="headerlink" title="下载 WSL："></a>下载 WSL：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">$ wsl --install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">$ wsl --version</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="下载-Ubuntu："><a href="#下载-Ubuntu：" class="headerlink" title="下载 Ubuntu："></a>下载 Ubuntu：</h4><p><img src="/2024/09/08/SSH%E4%B8%8EWSL/store.png" alt="在Microsoft Store随便选一个版本的Linux内核"></p>
<hr>
<h4 id="在-Ubuntu-中配置-SSH-服务器"><a href="#在-Ubuntu-中配置-SSH-服务器" class="headerlink" title="在 Ubuntu 中配置 SSH 服务器"></a>在 Ubuntu 中配置 SSH 服务器</h4><ul>
<li><p><strong>安装 ssh 服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行 ssh 服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service ssh start</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查 ssh 服务器是否已经开启成功</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status sshd</span><br></pre></td></tr></table></figure>

<p>如果有 <code>active (running)</code> 表示已经运行，否则则执行安装步骤</p>
</li>
<li><p><strong>修改配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加 `Port 22`</span></span><br><span class="line"><span class="comment"># 增加 `PermitRootLogin yes`</span></span><br><span class="line"><span class="comment">#如果配置文件中已经有上述两项配置，则修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看虚拟机的 ip</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="Windows-中-ssh-登录"><a href="#Windows-中-ssh-登录" class="headerlink" title="Windows 中 ssh 登录"></a>Windows 中 ssh 登录</h4><ul>
<li><p>打开 powershell，ssh 连接虚拟机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh &lt;username&gt;@&lt;ip_address&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果登录成功，表示 linux 配置成功。否则根据输入的错误日志，重新排查。</p>
</li>
</ul>
<hr>
<h4 id="VScode-配置"><a href="#VScode-配置" class="headerlink" title="VScode 配置"></a>VScode 配置</h4><ul>
<li><p><strong>安装 SSH 插件</strong></p>
<p><img src="/2024/09/08/SSH%E4%B8%8EWSL/extensions.png" alt="安装以上三个插件"></p>
</li>
<li><p><strong>SSH登录</strong></p>
<p><img src="/2024/09/08/SSH%E4%B8%8EWSL/remote.png" alt="点击加号添加服务器，在上方长栏输入ssh命令，并配置客户端"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host Ubuntu(自定义)</span><br><span class="line">    HostName 10.245.68.242	（虚拟机内部系统ip地址）</span><br><span class="line">    User &lt;user_name&gt;				（虚拟机内部系统登录账号）</span><br><span class="line">    IdentityFile &quot;C:\Users\&lt;User_name&gt;\.ssh\id_rsa&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 SSH 密钥免密登录</strong></p>
<ol>
<li><p><strong>制造密钥</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;&lt;email&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制密钥</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般位于 C:\Users\&lt;User_name&gt;\.ssh</span></span><br><span class="line"><span class="built_in">cat</span> /rsa_id.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>粘贴到 Ubuntu 虚拟机</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>最终效果</strong></p>
<p><img src="/2024/09/08/SSH%E4%B8%8EWSL/result.png" alt="在vscode终端直接访问Ubuntu虚拟机"></p>
</li>
</ul>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a target="_blank" rel="noopener" href="https://wangdoc.com/ssh/key">SSH 密钥登录</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghao-boke/p/17859096.html">vscode 连接本地虚拟机 Linux 系统</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">分治策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-07 13:50:31" itemprop="dateCreated datePublished" datetime="2024-09-07T13:50:31+08:00">2024-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-07 08:41:30" itemprop="dateModified" datetime="2024-11-07T08:41:30+08:00">2024-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/09/07/分治策略/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="何为分治"><a href="#何为分治" class="headerlink" title="何为分治"></a>何为分治</h3><p>分治算法通常用于解决<strong>递归问题</strong>，特别是在处理可以划分为相似子问题的情况下。</p>
<p>具体来说，分治算法分为三步（在每层递归中）：</p>
<ul>
<li><strong>分解（Divide）</strong>：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li><strong>解决（Conquer）</strong>：递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li><strong>合并（Combine）</strong>：将子问题的解组合成原问题的解。</li>
</ul>
<hr>
<h3 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h3><p>当我们<strong>计算分治算法的运行时间</strong>，自然地会使用递归公式来刻画。</p>
<p>所以如何<strong>求解递归式（求出算法运行时间的 Θ 或 O 渐近界）</strong>是很重要的。这里介绍三种方法：</p>
<ul>
<li><strong>代入法</strong>：先猜后证，数学归纳。</li>
<li><strong>递归树法</strong>：画树状图。</li>
<li><strong>主方法</strong>：求解形如<code>T(n) = aT(n/b) + f(n)</code>的递归式。</li>
</ul>
<hr>
<h4 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h4><p>代入法很朴素，就两步：</p>
<ul>
<li>猜测解的形式。</li>
<li>用数学归纳法证明：解是对的。</li>
</ul>
<hr>
<p><strong>例题</strong>：</p>
<blockquote>
<p><code>T(n) = 2T(n/2) + n</code></p>
</blockquote>
<p><strong>题解</strong>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们猜测 T(n) = O(n·lgn)</span><br><span class="line">即欲证：T(n) &lt;= c·n·lgn, ∃c &gt; 0</span><br><span class="line"></span><br><span class="line">归纳假设：T(n/2) &lt;= c(n/2)·lg(n/2), ∃c &gt; 0</span><br><span class="line">那么：</span><br><span class="line">T(n) &lt;= 2(c·n/2·lg(n/2)) + n</span><br><span class="line">	 = c·n·lgn - c·n + n</span><br><span class="line">	 &lt;= c·n·lgn</span><br><span class="line">	 当 c &gt;= 1 时</span><br><span class="line"></span><br><span class="line">综上，T(n) = O(n·lgn)。</span><br></pre></td></tr></table></figure>

<p>实际上，我们可以证明：<code>T(n) = Θ(n·lgn)</code>。</p>
<hr>
<h4 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h4><p>虽然代入法可以简洁地证明一个解确是递归式的正确解，但做出一个好的猜测可能会很困难。<strong>画递归树</strong>则适合用来<strong>生成好的猜测</strong>。</p>
<p>在递归树中，我们将递归式转换为一棵树：</p>
<ul>
<li>每个结点表示一个单一子问题的代价，子问题对应某次递归函数调用。</li>
<li>我们将树中<strong>每层中的代价</strong>求和，得到每层代价。</li>
<li>然后将<strong>所有层的代价</strong>求和，得到所有层次的递归调用的总代价。</li>
</ul>
<hr>
<p><strong>例题</strong>：</p>
<p><img src="https://ref.xht03.online/202411070834747.png"></p>
<p><strong>题解</strong>：</p>
<p>我们一层层展开递归树：</p>
<p><img src="https://ref.xht03.online/202411070835858.png"></p>
<p><img src="https://ref.xht03.online/202411070835624.png"></p>
<p><img src="https://ref.xht03.online/202411070835439.png"></p>
<p>则我们的时间总开销为：</p>
<p><img src="https://ref.xht03.online/202411070835077.png"></p>
<p>综上：<code>T(n)</code> 是 n 平方量级的。</p>
<hr>
<h4 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h4><p>对于一些常见且特别的递归式，我们给出<strong>主定理</strong>。</p>
<p><img src="https://ref.xht03.online/202411070836053.png"></p>
<p>主定理的证明，核心是：<strong>画递归树、分类讨论</strong>。</p>
<p><img src="https://ref.xht03.online/202411070837078.png"></p>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="归并排序-Vs-快速排序"><a href="#归并排序-Vs-快速排序" class="headerlink" title="归并排序 Vs 快速排序"></a>归并排序 Vs 快速排序</h4><p>归并排序和快速排序本质上都是分治算法。递推公式均是：<code>T(n) = 2·T(n/2) + O(n)</code>。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Divide</th>
<th align="center">Conquer</th>
<th align="center">Combine</th>
</tr>
</thead>
<tbody><tr>
<td align="center">归并排序</td>
<td align="center">O(1)</td>
<td align="center">2·T(n&#x2F;2)</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(n)</td>
<td align="center">2·T(n&#x2F;2)</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>根据主方法，我们可以知道，两者的渐近时间复杂度都是**<code>O(n·lgn)</code>**，都是很高效的排序方法。</p>
<p>但两者还是有细微的区别：</p>
<ul>
<li><p>快速排序实际执行的快慢是随机的，很大程度上受<code>pivot</code>的影响。</p>
<blockquote>
<p>最好情况是 pivot 恰好是当前子列的中位数。</p>
<p>最坏情况是 pivot 是最大或者最小值，则经历一次划分，几乎没有对换，也即是：花费O(n)时间却只排好了一个元素。</p>
</blockquote>
</li>
<li><p>在数据规模不大的时候，归并排序不一定很快。这是因为：归并排序有大量递归，函数栈很深，且每次调用函数都有额外开销。</p>
</li>
</ul>
<hr>
<p><strong>归并排序（Merge Sort）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序步骤：</span></span><br><span class="line"><span class="comment"># 1.Divide: Trivial.</span></span><br><span class="line"><span class="comment"># 2.Conquer: Recursively sort 2 subarrays.</span></span><br><span class="line"><span class="comment"># 3.Combine: Linear-time merge.</span></span><br><span class="line"><span class="comment"># 所以：T(n) = 2·T(n/2) + O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 找到中间位置，将数组分成两半</span></span><br><span class="line">        mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 分别对两半进行归并排序</span></span><br><span class="line">        left_half = merge_sort(arr[:mid])</span><br><span class="line">        right_half = merge_sort(arr[mid:])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并两个排序好的部分，线性时间内完成（merge函数省略了）</span></span><br><span class="line">        arr[:] = merge(left_half, right_half)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p><strong>快速排序（Quick Sort）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序步骤：</span></span><br><span class="line"><span class="comment"># 1.从列表中选择一个元素作为“基准”（pivot）。</span></span><br><span class="line"><span class="comment"># 2.重新排列列表，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（等于基准值的元素可以放到任一边）。</span></span><br><span class="line"><span class="comment"># 3.递归地把小于基准值元素的子列表和大于基准值元素的子列表排序。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = arr[<span class="number">0</span>]</span><br><span class="line">        less = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &lt;= pivot]</span><br><span class="line">        greater = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(less) + [pivot] + quick_sort(greater)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>求斐波那契数列第n项是一个非常经典的分治问题，但却有很多种不同的分治策略。</p>
<p><strong>算法1：自底向上</strong></p>
<p>从数列的第一项开始，一项项递推。（这也是简单的动态规划算法）</p>
<p>不难看出，该算法的时间复杂度是：<strong>O(n)</strong> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_dp</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>算法2：矩阵快速幂</strong></p>
<p>首先，我们注意到斐波那契数列如下的性质。</p>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/fibonacci.png"></p>
<p>所以，“求解数列第n项”转换成：<strong>如何快速的求矩阵的幂次</strong>。</p>
<p>如何求幂次呢？最简单的方法是：循环n次，累乘。但这显然不是最快速的。</p>
<p>最快速的方法是<strong>二分算法</strong>：将 n 次幂拆分成求解 [n&#x2F;2] 次幂的平方，以此类推。此时的时间开销为：**O(lgn)**。</p>
<hr>
<p><strong>算法3：通项公式</strong></p>
<p>常言道：“暴力出奇迹”。我们可以<strong>直接计算通项公式</strong>，结果为<code>float</code>型，再取整即可。</p>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/equation2.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码实现</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_binet</span>(<span class="params">n</span>):</span><br><span class="line">    phi = (<span class="number">1</span> + math.sqrt(<span class="number">5</span>)) / <span class="number">2</span></span><br><span class="line">    psi = (<span class="number">1</span> - math.sqrt(<span class="number">5</span>)) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">round</span>((phi**n - psi**n) / math.sqrt(<span class="number">5</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>计算机大量的计算是矩阵乘法。如何高效的完成两个矩阵的乘法呢？</p>
<p><strong>算法1：三重循环</strong></p>
<p>根据矩阵乘法的定义，我们可以在 <strong>O(n<sup>3</sup>)</strong> 内完成。</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">MATRIX_MULTIPLY</span><span class="params">(A, B)</span>:</span><br><span class="line">    # 三重循环，执行矩阵乘法</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n:                  # 遍历A的每一行</span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n:              # 遍历B的每一列</span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span> to n:</span><br><span class="line">                C[i][j] = C[i][j] + A[i][k] * B[k][j]</span><br><span class="line">    <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>算法2：分块矩阵</strong></p>
<p>简单起见，我们将 n 阶矩阵划分为4个 n&#x2F;2 阶矩阵，以此递归。</p>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/matrix.png"></p>
<p>则我们每次递归需要的时间开销：</p>
<ul>
<li>划分分块矩阵</li>
<li>递归计算A、B的8个子矩阵乘积</li>
<li>求和得到C<sub>11</sub>、C<sub>12</sub>、C<sub>21</sub>、C<sub>22</sub>。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Divide</th>
<th align="center">Conquer</th>
<th align="center">Combine</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>T(n)</strong></td>
<td align="center"><strong>O(1)</strong></td>
<td align="center"><strong>8·T(n&#x2F;2)</strong></td>
<td align="center">4·( n&#x2F;2 )<sup>2</sup> &#x3D; <strong>O(n<sup>2</sup>)</strong></td>
</tr>
</tbody></table>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/matrix2.png"></p>
<p>但非常遗憾，根据主方法，如此二分算法的时间开销仍是：**O(n<sup>3</sup>)**。</p>
<p>如何更快速呢？</p>
<p>核心在于：每次递归时，<strong>计算尽可能少的矩阵乘法</strong>，再通过加法组合出我们想要的子矩阵。（因为：矩阵乘法是 O(n<sup>3</sup>)，而矩阵加法是 O(n<sup>2</sup>)。）</p>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/matirx4.png"></p>
<p>对此，我们如下改进：</p>
<p>我们只计算如下7个矩阵乘法。</p>
<p><img src="/2024/09/07/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/matirx3.png"></p>
<p>再通过加法，算出C矩阵。</p>
<ul>
<li><em>r</em> &#x3D; <em>P</em><sub>5</sub> + <em>P</em><sub>4</sub> − <em>P</em><sub>2</sub> + <em>P</em><sub>6</sub></li>
<li><em>s</em> &#x3D; <em>P</em><sub>1</sub> + <em>P</em><sub>2</sub></li>
<li><em>t</em> &#x3D; <em>P</em><sub>3 </sub> + <em>P</em><sub>4</sub></li>
<li><em>u</em> &#x3D; <em>P</em><sub>5</sub> + <em>P</em><sub>1</sub> − <em>P</em><sub>3</sub> − <em>P</em><sub>7</sub></li>
</ul>
<p>此时算法的时间开销是：**O(n<sup>log<sub>2</sub>7</sup>)**。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/09/05/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/05/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">渐近分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-05 15:48:21" itemprop="dateCreated datePublished" datetime="2024-09-05T15:48:21+08:00">2024-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-07 08:33:04" itemprop="dateModified" datetime="2024-11-07T08:33:04+08:00">2024-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Algorithm/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Algorithm</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/09/05/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/09/05/渐近分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="函数增长"><a href="#函数增长" class="headerlink" title="函数增长"></a>函数增长</h3><p>在比较算法性能时，虽然有时我们能够确定一个算法的<strong>精确运行时间</strong>，但是通常并不值得花力气来计算它（精度多余了）。对于足够大的输入，算法的运行时间中的<strong>常数倍数</strong>和<strong>低阶项</strong>相对于输入规模的影响变得不那么显著。</p>
<p>因此，我们研究<strong>渐近效率</strong>。我们关心：当输入规模无限增加时，在极限中，算法的运行时间如何随着输入规模的变大而增加。</p>
<hr>
<h3 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h3><p>以下是常用的渐近记号。</p>
<p><img src="https://ref.xht03.online/202411070831468.jpg"></p>
<p>对于两个函数<code>f</code>、<code>g</code>的渐近比较，我们可以将其类比成实数<code>a</code>、<code>b</code>的比较。</p>
<p><img src="https://ref.xht03.online/202411070831865.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/" class="post-title-link" itemprop="url">静态插桩</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-23 11:14:25" itemprop="dateCreated datePublished" datetime="2024-08-23T11:14:25+08:00">2024-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-01 10:14:56" itemprop="dateModified" datetime="2024-09-01T10:14:56+08:00">2024-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Lee/" itemprop="url" rel="index"><span itemprop="name">Lee</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/08/23/静态插桩/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>一段代码，从 <code>.c</code> 源文件到可执行文件经历了4个步骤：</p>
<ul>
<li><strong>预处理（Preprocessing）</strong>：主要处理源代码中以<code>#</code>开始的预编译指令，比如<code>#include</code>、<code>#define</code> 等等。预处理完得到的是<code>.i</code>文件。</li>
<li><strong>编译（Compilation）</strong>：编译完成后，得到的是：汇编文件（<code>.s</code>）</li>
<li><strong>汇编（Assembly）</strong>：将汇编代码转换成机器可以执行的指令，每一条汇编指令都会对应一条机器指令。汇编完成后，得到的是：可重定向目标文件（<code>.o</code>）。</li>
<li><strong>链接（Linking）</strong>：通常一份文件会调用其他文件中编写的函数，但当前文件怎么知道去哪里寻找它想调用的函数呢？这就需要链接。链接完成后，得到的是：可执行目标文件。</li>
</ul>
<p>其中：可重定向目标文件、可执行目标文件都必须符合<strong>ELF格式（Executable and Linkable Format）</strong>，因此也可称为：<strong>ELF文件</strong>。</p>
<hr>
<p>ELF文件包含一下三个部分：</p>
<ul>
<li><strong>ELF header</strong></li>
<li><strong>Sections</strong></li>
<li><strong>Section header table</strong></li>
</ul>
<p>下图是一个 Hello World 可执行程序的 ELF 格式实例。</p>
<p><img src="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\静态插桩\ELF.png" alt="ELF"></p>
<p>我们可以通过命令行工具<code>readelf</code>查看 elf 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h demo   <span class="comment">#查看elf header</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\静态插桩\elf_header.png" alt="ELF header"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S demo   <span class="comment">#查看各个section信息</span></span><br></pre></td></tr></table></figure>

<p>  <img src="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\静态插桩\sections1.png" alt="Sections"></p>
<hr>
<p>这里容易混淆的是：<strong>ELF Header</strong>、<strong>Program Header</strong>、<strong>Section Header</strong>：</p>
<ul>
<li><strong>ELF Header</strong> 是 ELF 文件的文件头，它是文件的起始部分，为加载器和链接器提供必要的信息来处理文件。</li>
<li><strong>Program Header</strong> 是一个数据结构，它定义了程序如何加载到内存中。每个 <strong>Program Header</strong> 都包含了一个段（<strong>Segment</strong>）的加载信息，比如它的类型、在文件中的偏移量、在内存中的地址、大小等。</li>
<li><strong>Program Header Table</strong> 是一个由多个 <strong>Program Header</strong> 组成的数组，它按照程序头的顺序排列。<strong>Program Header Table</strong> 通常位于 <strong>ELF Header</strong> 之后，通常在文件的开始部分，这样加载器可以快速地找到并读取它。</li>
<li><strong>Section Header</strong> 定义了文件中的节（<strong>Section</strong>）的属性和信息。每个节头条目（Section Header Entry）都包含了关于一个特定节的元数据。</li>
</ul>
<p>注意：</p>
<p>Sections 中的第一个 Section（索引为0的section）就是 <strong>Program Header Table</strong>。</p>
<blockquote>
<p>以之前图中 ELF 文件为例。</p>
<p>**ELF Header **占据最开始的64个字节。</p>
<p>紧接着是<strong>Program Header Table</strong>，总共占据 56 * 13 &#x3D; 728个字节。</p>
<p>所以真正的第一个section（.interp）开始地址应该是：64 + 728 &#x3D; 792 &#x3D; 0x318。</p>
</blockquote>
<hr>
<p>另外一个容易混淆的是：<strong>节（Section）</strong>、<strong>段（Segment）</strong>。</p>
<ul>
<li><p>Section 称为节，是指在汇编源码中经由关键字section或segment修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说”节”最初诞生于目标文件中。</p>
</li>
<li><p>Segment 称为段，是，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的Segment。</p>
</li>
</ul>
<p><img src="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\静态插桩\Segment.png" alt="Section Vs Segment"></p>
<ul>
<li>左边是ELF的<strong>链接</strong>视图，可以理解为是<strong>目标文件</strong>的内容布局。</li>
<li>右边是ELF的<strong>执行</strong>视图，可以理解为<strong>可执行文件</strong>的内容布局。</li>
</ul>
<p>注意：目标代码文件的内容是由 <strong>Section</strong> 组成的，而可执行文件的内容是由 <strong>Segment</strong> 组成的。</p>
<ul>
<li><p>我们查看汇编程序时，<code>.text</code>，<code>.bss</code>，<code>.data</code> 都指的是 <strong>Section</strong>。目标代码文件中的 <strong>Section</strong> 和 <strong>Section Header Table</strong> 中的条目是一一对应的。<strong>Section</strong> 的信息用于链接器对代码重定位。</p>
</li>
<li><p>而文件载入内存执行时，是以 <strong>Segment</strong> 组织的，每个 <strong>Segment</strong> 对应 ELF 文件中 <strong>Program Header Table</strong> 中的一个条目，用来建立可执行文件的进程映像。链接器将目标文件中属性相同的多个 <strong>Section</strong> 合并，从而形成新的可执行文件；合并后的 <strong>Section</strong> 的集合，称为 <strong>Segment</strong>。例如：所有<code>.text</code> <strong>Section</strong> 会被合并成一个新的<code>.text</code> <strong>Segment</strong>。</p>
</li>
</ul>
<p>注意：在目标文件中，<strong>Program Header</strong> 不是必须的，我们用 gcc 生成的目标文件也不包含 <strong>Program Header</strong>。</p>
<hr>
<p>在所有Sections中，有一个section比较特殊：<code>.shstrtab</code>。</p>
<p><img src="/2024/08/23/%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\静态插桩\shstrtab.png" alt="Section Header String Table"></p>
<blockquote>
<p>在之前查看 <strong>ELF Header</strong> 的时候，<strong>ELF Header</strong> 就提供了 <code>.shstrtab</code> Section 的索引是多少。</p>
</blockquote>
<ul>
<li><p><strong>节头字符串表</strong>（Section Header String Table，简称SHSTRTAB）是 ELF 文件中的一个特殊 section。它包含所有 section 名称的字符串。</p>
</li>
<li><p>每个 <strong>Section Header</strong> 中的<code>sh_name</code>字段是一个索引，指向节头字符串表中的一个位置，该位置存储了该 section 的名称。</p>
</li>
<li><p>节头字符串表本质上是一个以空字符（<code>\0</code>）分隔的字符串集合。每个section的名称在这个表中都有一个唯一的偏移量，该偏移量存储在对应section头部的<code>sh_name</code>字段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00: &quot;\0&quot;</span><br><span class="line">0x01: &quot;.text\0&quot;</span><br><span class="line">0x07: &quot;.data\0&quot;</span><br><span class="line">0x0D: &quot;.bss\0&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p>我们希望采用跳板技术实现静态插桩。</p>
<ul>
<li><strong>跳板技术</strong>：简单来说，就是通过设置一个中间点（跳板），让程序先跳到这个中间点，然后由这个中间点再跳到最终的目标函数去执行。这个过程就像是设置了一个中转站，让程序先到中转站，再由中转站引导到目的地。</li>
<li>我们给目标程序<strong>新增加一个section</strong>作为跳板（trampoline）。</li>
</ul>
<p>具体分为两个函数：</p>
<ol>
<li>创造trampoline空间的函数：Crt_Trpline</li>
<li>进行二进制插桩的函数： Sinsert</li>
<li>复原函数：recover</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/bfd.pdf">bfd.pdf</a></p>
<p>在BFD（Binary File Descriptor）库中，<code>bfd_make_section</code> 及其相关函数用于创建新的节（section）并将其附加到BFD（Binary File Descriptor）结构中。这些函数提供了不同的选项和功能，以适应不同的使用场景。以下是一些常见的 <code>make section</code> 函数及其区别和功能：</p>
<ol>
<li><p><strong><code>bfd_make_section</code></strong></p>
<ul>
<li>功能：创建一个新的空节，并将其附加到BFD的节链表中。</li>
<li>参数：只需要提供BFD和节的名称。</li>
<li>特点：如果同名节已存在，则不会创建新的节，而是返回现有的节。</li>
</ul>
</li>
<li><p><strong><code>bfd_make_section_anyway</code></strong></p>
<ul>
<li>功能：创建一个新的空节，即使同名节已存在，也会创建新的节，并附加到BFD的节链表中。</li>
<li>参数：提供BFD和节的名称。</li>
<li>特点：不检查是否已存在同名节，总是创建新的节。</li>
</ul>
</li>
<li><p><strong><code>bfd_make_section_with_flags</code></strong></p>
<ul>
<li>功能：创建一个新的节，并为其设置特定的标志（flags）。</li>
<li>参数：提供BFD、节的名称和要设置的标志。</li>
<li>特点：允许在创建节时指定节的属性，如是否可加载、是否可执行等。</li>
</ul>
</li>
<li><p><strong><code>bfd_make_section_anyway_with_flags</code></strong></p>
<ul>
<li>功能：创建一个新的节，并为其设置特定的标志，即使同名节已存在。</li>
<li>参数：提供BFD、节的名称和要设置的标志。</li>
<li>特点：结合了 <code>bfd_make_section_with_flags</code> 和 <code>bfd_make_section_anyway</code> 的功能。</li>
</ul>
</li>
<li><p><strong><code>bfd_make_section_old_way</code></strong></p>
<ul>
<li>功能：使用旧方法创建一个新的节。</li>
<li>参数：只需要提供BFD和节的名称。</li>
<li>特点：如果同名节已存在，则不会创建新的节，而是返回现有的节。这是较老的API，可能在新版本的BFD中不再推荐使用。</li>
</ul>
</li>
<li><p><strong><code>bfd_set_section_flags</code></strong></p>
<ul>
<li>功能：设置现有节的标志。</li>
<li>参数：提供节和要设置的标志。</li>
<li>特点：不创建新节，只修改现有节的属性。</li>
</ul>
</li>
<li><p><strong><code>bfd_set_section_size</code></strong></p>
<ul>
<li>功能：设置现有节的大小。</li>
<li>参数：提供节和新的大小。</li>
<li>特点：不创建新节，只修改现有节的大小。</li>
</ul>
</li>
<li><p><strong><code>bfd_set_section_contents</code></strong></p>
<ul>
<li>功能：设置现有节的内容。</li>
<li>参数：提供BFD、节、数据缓冲区、偏移量和数据大小。</li>
<li>特点：不创建新节，只修改现有节的内容。</li>
</ul>
</li>
</ol>
<p>这些函数提供了灵活的方式来创建和管理BFD中的节。选择哪个函数取决于你的具体需求，比如是否需要检查同名节的存在、是否需要设置特定的节属性等。在实际应用中，应根据目标文件格式和操作需求选择合适的函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="如何新增section"><a href="#如何新增section" class="headerlink" title="如何新增section"></a>如何新增section</h4><p>我们主要通过c语言标准库中提供的工具来编辑 elf header。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;elf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libelf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gelf.h&gt;</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">数据库笔记3：Indexing and Hashing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-21 21:35:40" itemprop="dateCreated datePublished" datetime="2024-06-21T21:35:40+08:00">2024-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-23 15:15:00" itemprop="dateModified" datetime="2024-06-23T15:15:00+08:00">2024-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Database/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/06/21/数据库3-索引/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>就像查字典有拼音索引、部首索引、笔画索引一样，为了方便查询，数据库中也有索引。主要有以下两种索引：</p>
<ul>
<li><strong>顺序索引（Ordered indices）</strong></li>
<li><strong>哈希索引（Hash indices）</strong></li>
</ul>
<p>首先，我们介绍一些预备知识。</p>
<p>查询记录时，我们会根据一个属性或者多个属性进行搜索。这个属性集，我们称为：<strong>搜索码（search key）</strong>。</p>
<p>索引包含若干索引项。<strong>索引项（index entry）</strong>由一个搜索码值和指向记录的一个或多个指针构成。</p>
<p>考虑到：数据库中更新记录，可以等价为先删除旧记录，在插入新记录。所以，我们只需要考虑插入索引和删除索引即可。</p>
<h3 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h3><p>在顺序索引中，<strong>索引项是按照 search key 进行排序存储的</strong>。</p>
<p>但是数据的存储顺序不一定与索引项的排序顺序相同。所以，根据是否与数据的排序顺序相符合，我们将索引分为两类：</p>
<ul>
<li><p><strong>主索引（ Clustering Index）</strong>：索引顺序与数据顺序相同。</p>
</li>
<li><p><strong>辅助索引（Non-clustering Index）</strong>：索引顺序与数据顺序不同。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/secondary-index.png" alt="secondary index"></p>
</li>
</ul>
<p>除了这种分类方式，还可以根据索引项的密度进行分类：</p>
<ul>
<li><p><strong>稠密索引（Dense Index）</strong>：每一个搜索码都对应地有一个索引项。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/dense-index.png" alt="dense index (but not clustering)"></p>
</li>
<li><p><strong>稀疏索引（Sparse Index）</strong>：索引项只涵盖了部分搜索码的可能取值。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/sparse-index.png" alt="sparse index"></p>
</li>
</ul>
<p>请注意：<strong>辅助索引必须是稠密索引</strong>，即每个搜索码都有一个索引项。这是因为：辅助索引的顺序与数据顺序不同，如果一个搜索码没有对应的索引项，那么这个记录可能出现在数据库中的任何地方，那么索引也就失去作用了。</p>
<p>显然，如果索引是聚集且稀疏的，查询一个记录则可以这么做：先在索引中寻找不大于当前搜索码值的最大索引，在从这个索引项指向的记录开始，依次往后搜索。</p>
<p>所以，稀疏索引的好处时可以使用更少的空间来存储索引，但定位一个记录的时间会更慢一点。所以一个不错的权衡是：生成一个稀疏索引，<strong>为每一个块建一个索引项</strong>（generate a sparse index with an index entry for every block in file）。</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>B+树索引的好处和缺点如下：</p>
<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">每次插入删除会自动重组索引结构</td>
<td align="center">每次插入删除都有额外的时间开销</td>
</tr>
<tr>
<td align="center">不需要重组整个文件来维持性能</td>
<td align="center">维持B+树的空间开销</td>
</tr>
</tbody></table>
<hr>
<h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><blockquote>
<p>中间节点（internal nodes）：既不是根节点，也不是叶节点</p>
</blockquote>
<p>B+树是一个有根节点的树，且满足以下性质：</p>
<ul>
<li>所有从根节点到叶节点的路径都一样长。（平衡树）</li>
<li>每个中间节点有 ⌈n&#x2F;2⌉ 到 n 个子节点。（n预先给定的）</li>
<li>叶节点有 ⌈(n-1)&#x2F;2⌉ 到 n-1个值。</li>
<li>如果根节点不是叶节点，则根节点至少有两个子节点。</li>
<li>如果根节点是叶节点，则根节点有 0 到 (n-1) 个值。</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/B-plus.png" alt="B+ tree 1"></p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/B-plus-example.png" alt="B+ tree 2"></p>
<hr>
<h4 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h4><p>对于非叶子节点：</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/node-structure.png" alt="B+ tree node structure"></p>
<p>其中：</p>
<ul>
<li><p>指针个数 n 称为：<strong>扇出（fanout）</strong>。</p>
</li>
<li><p>**K<sub>1</sub> &lt; K<sub>2</sub> &lt; …… &lt; K<sub>n-1</sub>**（假设搜索码不会重复）</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/k-condition.png" alt="K-condition"></p>
</li>
</ul>
<p>如果是叶子节点，则还有如下性质：</p>
<ul>
<li>最后一个指针 P<sub>n</sub> 指向下一个叶子节点。</li>
<li>P<sub>i</sub> 指向的记录的搜索码取值为 K<sub>i</sub> 。</li>
<li>如果叶节点 L<sub>i</sub> &lt; L<sub>j</sub> ，那么叶节点 L<sub>i</sub> 中所有记录的搜索码都小于等于 L<sub>j</sub> 中的。</li>
</ul>
<p>如果搜索码可能重复，那么 K<sub>i</sub> 序列不再是严格单增的。而是：<strong>K<sub>1</sub> &lt;&#x3D; K<sub>2</sub> &lt;&#x3D; …… &lt;&#x3D; K<sub>n-1</sub></strong></p>
<hr>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>在 B+ 树种查找搜索码为 V 的记录，方法如下（伪代码表示）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set C = root node</span><br><span class="line"></span><br><span class="line">while(C is not a leaf node) &#123;</span><br><span class="line">    Let i = smallest number s.t. V &lt;= C.Ki</span><br><span class="line">    if no such i exists, then set C = C.Pm</span><br><span class="line">    	where Pm = last non-null pointer in the node</span><br><span class="line">    else if(V = C.Ki) then set C = C.Pi+1</span><br><span class="line">    else set C = C.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Let i be the least value s.t. Ki = V</span><br><span class="line"></span><br><span class="line">if there is such a value i, return (C, i)</span><br><span class="line">else return null</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/query-example.png" alt="query example"></p>
<hr>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>由于 B+ 树对每个节点的子节点数有限制，所以每次插入删除都可能需要：</p>
<ul>
<li><strong>Split</strong> a node if the node becomes too large.</li>
<li><strong>Coalesce (合并)</strong> two or more nodes if a node becomes too  small.</li>
</ul>
<p>分裂和合并的规则描述起来比较复杂，我们直接看例子。</p>
<ol>
<li><p>插入”Adam”：</p>
<ul>
<li><p>先根据之前的查询的流程来定位。</p>
</li>
<li><p>插入“Adam”，检查是否需要分裂。若需要，则分裂。</p>
</li>
<li><p>子节点分裂可能导致父节点也需要分裂，所以需要一层层向上检查。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/split-example1.1.png" alt="locate the node"></p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/split-node.png" alt="split the node"></p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/split-result.png" alt="split result"></p>
</li>
</ul>
</li>
<li><p>在1的基础上，再插入“Lamport”：</p>
<ul>
<li>与之前类似，不过这次插入导致上层节点也需要分裂。</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/insert-result.png" alt="insert result"></p>
</li>
<li><p>删除“Srinivasan”：</p>
<ul>
<li>删除目标节点。</li>
<li>如果删除后子节点数不符合要求，那么与兄弟节点进行合并。</li>
<li>合并后，父节点可能也需要合并，所以需要向上一层层检查。</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/delete-process.png" alt="delete example1"></p>
</li>
<li><p>再删除“Singh”和“Wu”：</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/delete-example2.png" alt="delete example2"></p>
</li>
<li><p>再删除“Gold”：</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/delete-example3.png" alt="delete example3"></p>
</li>
</ol>
<hr>
<h4 id="B-树索引-1"><a href="#B-树索引-1" class="headerlink" title="B 树索引"></a>B 树索引</h4><p>B 树类似于 B+ 树。B 树要求：<strong>每个搜索码的取值只能出现一次</strong>，从而消除重复储存搜索码的值。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/B-tree.png" alt="B tree"></p>
<p>B 树优点在于：</p>
<ul>
<li>使用了更少的节点</li>
<li>可能更快地找到搜索码的值（因为不一定要遍历到叶节点）</li>
</ul>
<p>B 树缺点在于：</p>
<ul>
<li>只有很小一部分的搜索码的值是可以更快找到的。</li>
<li>插入和删除操作都会更复杂</li>
<li>实现也更加麻烦</li>
</ul>
<p>总的来说，B树不如B+树，缺点远胜优点。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>之前的索引方式都需要建立一种索引结构，但哈希索引则可以避免：</p>
<ul>
<li>通过计算<strong>哈希函数（hash function）</strong>，可以由 search key 计算得到包含目标记录的块地址。</li>
<li>A <strong>bucket</strong> is a unit of storage containing one or more records typically a disk block.</li>
</ul>
<hr>
<h4 id="静态哈希"><a href="#静态哈希" class="headerlink" title="静态哈希"></a>静态哈希</h4><p>在静态哈希种，<strong>桶的数量是固定的</strong>。</p>
<p>常见的哈希函数都是：<strong>计算搜索码的二进制表示，再模上桶的数量</strong>。</p>
<p>例如下图中：根据dept_name，在instructor表上建立哈希索引。</p>
<blockquote>
<p>桶个数&#x3D;8。</p>
<p>哈希函数是：将各字母在字母表中的序号相加，再 mod 8。</p>
</blockquote>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/static-hash.png" alt="static hash"></p>
<hr>
<h4 id="溢出桶"><a href="#溢出桶" class="headerlink" title="溢出桶"></a>溢出桶</h4><p>但如果插入记录时，发现桶里已经装满了记录，这就是：<strong>桶溢出（Bucket Overflow）</strong>。一般有如下两种原因：</p>
<ul>
<li>桶确实不足。即使所有桶全部装满，也装不完全部记录。</li>
<li>很多记录都装进了同一个桶，而其他很多桶还有很多空间。<strong>（Skew in distribution of records）</strong></li>
</ul>
<p>解决办法也很朴素：加桶（谁溢出，谁加桶）。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/overflow-bucket.png" alt="overflow bucket"></p>
<hr>
<h4 id="动态哈希"><a href="#动态哈希" class="headerlink" title="动态哈希"></a>动态哈希</h4><p>静态哈希虽然易于实现，但缺点也明显：桶的数量是固定。</p>
<ul>
<li>如果设置的太小，那么需要不停的添加溢出桶，且一个 hash地址 中的记录也会非常多，导致查询效率降低。</li>
<li>如果设置的太大，在数据规模还没起来时，大量空间被浪费了。</li>
</ul>
<p>所以我们希望：桶的数量能动态变化。这便是：动态哈希。</p>
<p>这里，我们主要介绍：<strong>可扩充散列（Extendable Hashing）</strong>。</p>
<p>可扩充散列的核心思想是：<strong>当存储的记录不多时，我们只使用 hash 值的前几位。当存在有桶溢出的情况时，我们再使用更多的 hash 值位数。</strong></p>
<p>严格来说：</p>
<ul>
<li>假定 hash 函数产生的 hash 值是 b 位。</li>
<li>设每个桶所对应的 hash 值是 i 位，（0 &lt;&#x3D; i &lt;&#x3D; b）。</li>
<li>当一条记录经过 hash 函数计算得的 hash 值的前 i 位与桶的 hash 值相同时，这条记录存储在这个桶里。</li>
<li>当这个桶溢出时，这个桶会分成两个桶。它们的 hash 值都是 i+1 位，且前 i 位继承原来桶的 hash 值，最后一位则分别时0、1。原来桶中的记录依据 hash 值分别装进新的两个桶中。</li>
</ul>
<p>具体来说，我们举例说明：</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/extendable-hash1.png" alt="example"></p>
<ul>
<li>插入“Mozart”：</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/extendable-example2.png" alt="Insert Mozart"></p>
<ul>
<li><p>插入“Einstein”：</p>
<blockquote>
<p>这时2号桶的 i<sub>2</sub> 需要加1，且 bucket address table 的前缀长度 &#x3D; max { i<sub>k</sub> | k &#x3D; 1, 2, … , b} 也会随着加1。</p>
</blockquote>
</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/exetendable-example3.png" alt="Insert Einstein"></p>
<ul>
<li>插入“Gold”：</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/extendable-example4.png" alt="Insert Gold"></p>
<hr>
<h4 id="一些比较"><a href="#一些比较" class="headerlink" title="一些比较"></a>一些比较</h4><p>如果是范围搜索，顺序索引更好。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/range-query.png" alt="range query"></p>
<p>如果是搜索某个具体的值，哈希索引更好。</p>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/key-query.png" alt="query based on a key"></p>
<h3 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h3><p>位图索引（Bitmap Index）是一种特殊但非常高效的索引。但<strong>它一般只建立一个属性上，且该属性的可能取值很少</strong>（比如：性别、国家、省）。</p>
<p>具体来说：</p>
<ul>
<li>这个属性的每一个取值都有相应的 bitmap。</li>
<li>一个取值 V 的 bitmap 的第 i 位为1，表示第i条记录的该属性是 V。若是0，则不是 V。</li>
</ul>
<p><img src="/2024/06/21/%E6%95%B0%E6%8D%AE%E5%BA%933-%E7%B4%A2%E5%BC%95/bitmap.png" alt="bitmap"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">数据库笔记2：Concurrency Control</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-13 18:35:07" itemprop="dateCreated datePublished" datetime="2024-06-13T18:35:07+08:00">2024-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-21 21:32:41" itemprop="dateModified" datetime="2024-06-21T21:32:41+08:00">2024-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Database/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/06/13/数据库2-并行控制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>当数据库中多个事务并发执行时，事务的隔离性不一定能保持。为了保持事务的隔离性，数据库必须控制不同事务之间的互动。</p>
<p>这里我们将介绍两种常见的<strong>并发控制（concurrency control）</strong>的机制：</p>
<ul>
<li>two-phase locking（二相锁）</li>
<li>timestamp（时间戳）</li>
</ul>
<h3 id="二相锁"><a href="#二相锁" class="headerlink" title="二相锁"></a>二相锁</h3><p>就像“编辑在线文档”，为了避免自己写的内容被其他人篡改，最简单的方式就是：在自己编辑的时候给文档上锁，只有自己能修改其中的内容。等到修改完成后，再打开锁，允许其他人进行修改。</p>
<p>数据库中也是类似的。</p>
<hr>
<h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>数据项可以被加上以下两种模式的锁：</p>
<ul>
<li><strong>共享锁</strong> shared mode (S)：数据项只能被读。</li>
<li><strong>排他锁</strong> exclusive mode (X)：数据项可以被读或者写。</li>
</ul>
<p>显然，多个事务可以同时持有同一个数据的共享锁。但若有一个事务持有这个数据的排他锁，那么其他事务不能再持有该数据的共享锁。所以，不同锁之间也是存在<strong>兼容性（Lock-compatibility）</strong>的。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/compatibility.png" alt="Lock-compatibility"></p>
<p>当一个事务想访问一个数据时，它会向<strong>并发控制管理器（concurrency-control manager）</strong>发出请求。如果当前不存在与其不兼容的锁，则向该事务授权新锁；否则需要等待不兼容的锁全部被释放，才能再授权新锁。</p>
<hr>
<h4 id="基于锁的协议"><a href="#基于锁的协议" class="headerlink" title="基于锁的协议"></a>基于锁的协议</h4><p>但需要注意：<strong>上锁并不能保证调度是可序列化的</strong>。</p>
<p>例如：A账户有100元，B账户有200元；T1是从B向A转账50元，T2是打印A、B账户金额总和。具体调度如下图。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example1.png" alt="example1"></p>
<p>可以发现，这样的调度就不满足事务的一致性。原因在于：</p>
<ul>
<li>T1 过早的释放了数据B的锁。这导致 T2 误以为自己已经获得了所有需要的数据，就开始执行。但 T2 读取的A并不是 T1 更新后的值。</li>
</ul>
<p>因此我们还需要：<strong>基于锁的协议（Lock-Based Protocols）</strong>来对申请和释放锁进行规定。（所谓协议，就是一些需遵守的规则罢了）</p>
<p>所以，针对上面例子，我们可以规定：<strong>释放锁被推迟到事务结束时</strong>。这样就能确保调度时可序列化的。</p>
<blockquote>
<p>Unlocking is delayed to the end of the transaction.</p>
</blockquote>
<hr>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当我们使用锁时，可能出现以下这种情况：</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/deadlock.png" alt="deadlock"></p>
<p>T3 和 T4 都需要数据 A、B。但 T3 持有B并给B上锁；T4 持有A并给A上锁。此时，T3 和 T4 都有彼此想要的数据项，但又都不愿意释放出自己手中的数据。于是调度就僵持在这里，无法进行。这种情况，我们称之为：<strong>死锁（deadlock）</strong>。</p>
<hr>
<p>就像《剪刀手爱德华》里说的：“如果我没有刀，我无法保护你；如果我拿着刀，我无法拥抱你。”如果不采用锁，无法保证事务的一致性；但如果采用锁，又会产生死锁的情况。</p>
<p>“两害相权取其轻”。相较于数据的不一致，死锁是可以接受的。 处理死锁的思路一般有两种：</p>
<ul>
<li>预防：采用 deadlock prevention protocol，保证系统永远不会进入死锁状态。</li>
<li>修复：允许系统进入死锁状态，进入后进行恢复就好。</li>
</ul>
<p>当系统有很高频率进入死锁状态时，“预防”是更好的选择。否则“进入后再恢复”是更高效的方案。</p>
<hr>
<p><strong>死锁预防（deadlock prevention）</strong>有以下两种常见方式：</p>
<ul>
<li>一个事务在执行的开始就把所有需要的数据上锁。要么一次性锁住所有需要的数据，要么一个也不锁。</li>
<li>系统给所有资源分配一个全局的顺序号，事务必须按顺序请求资源。也就是说：如果一个事务已经持有了一个资源，它只能请求顺序号更大的资源，不能请求顺序号更小的资源。但如果一个事务需要请求顺序号更小的资源，它必须：1. 释放当前持有的所有锁；2. 按照顺序从小到大重新申请所有所需的资源。</li>
</ul>
<p>第一种策略易于实现，但缺点明显：在事务的开始时，系统难以预测它究竟需要哪些数据；其次这样的数据利用效率非常低。</p>
<p>第二种策略可能不那么易于理解，我们举一个例子：</p>
<p>假设有三个资源 A、B 和 C，它们的顺序号分别是 1、2 和 3。</p>
<ul>
<li>事务 T1 需要锁定资源 B 和 A。</li>
<li>事务 T2 需要锁定资源 A 和 B。</li>
</ul>
<p>此时事务 T1 已经锁定资源 B，事务 T2 已经锁定资源 A。但由于 资源A顺序 &lt; 资源B顺序 ，事务 T1 不能锁定 A，所以它会释放资源 B，重新请求上锁，这样事务 T2 就能顺利获得资源 B，从而避免死锁。</p>
<p>这种策略的优势在于：易于实现，不需要对底层的并发控制系统进行修改。</p>
<hr>
<p>死锁恢复一般采用<strong>抢占和回滚（preemption and transaction rollbacks）</strong>：其实就是，抢走一个事务手中的锁，并将这些锁给其他事务，并将被抢的事务回滚。但是谁抢走谁呢？这就需要一个判断标准：<strong>事务的时间戳（Transaction timestamps）</strong>。</p>
<p>形象地比喻就是“银行办理业务”：每个人都会到大厅机器上取一个号码，这个就是你的时间戳。大家根据时间戳先后决定谁先办理业务。</p>
<p>在数据库中也是相似的，一般有两种策略：</p>
<ul>
<li><strong>Wait-Die Scheme</strong>（new-die &amp; old-wait）：如果一个较老的事务请求一个被较新的事务持有的资源，那么较老的事务会等待。如果一个较新的事务请求一个被较老的事务持有的资源，那么较新的事务会被回滚。</li>
<li><strong>Wound-Wait Scheme</strong>（new-wait &amp; old-die）：如果果一个较老的事务请求一个被较新的事务持有的资源，那么较新的事务会被立即回滚。如果一个较新的事务请求一个被较老的事务持有的资源，那么较新的事务会等待。</li>
</ul>
<p>举例说明一下：</p>
<ul>
<li>事务 T14、T15 和 T16 的时间戳分别为 5、10 和 15。</li>
<li>在 Wait-Die 方案下：如果 T14 请求一个由 T15 持有的数据项，那么 T14 将会等待。如果 T16 请求一个由 T15 持有的数据项，那么 T16 将会被回滚。</li>
<li>在 Wound-Wait 方案下：如果 T14 请求一个由 T15 持有的数据项，那么数据项将从 T15 中被抢占，T15 将会被回滚。如果 T16 请求一个由 T15 持有的数据项，那么 T16 将会等待。</li>
</ul>
<p>但这两种策略都会带来不必要的回滚。</p>
<hr>
<p>还有一种解决死锁的方式：<strong>锁超时（lock-timeout）</strong>：申请锁的事务最多等待一定时间，如果没有得到锁，则该事务自动回滚，并重启。</p>
<p>这种方式介于预防和恢复之间。但超时的时间限制（timeout interval）是不好把握的。太长，死锁卡住的时间就久；太短，一个事务太没耐心，从而可能不停回滚。</p>
<hr>
<h4 id="饿死"><a href="#饿死" class="headerlink" title="饿死"></a>饿死</h4><p>当我们使用锁时，会出现以下这种情况：</p>
<ul>
<li>一个事务可能在等待某个数据的排他锁，同时，许多其他事务请求并获得了该项目上的S锁（共享锁）。</li>
</ul>
<p>形象的比喻就是“银行业务办理窗口”：</p>
<ul>
<li>事务比作人，数据比作窗口，若干事务正在排队访问数据。你前面有一个人正在读数据，但你是想写数据，你只能等待。这这时后面的人说：“嘿，我就读数据，让我凑过去看一眼”，于是他插队到你前面（获得了共享锁）。后面所有想读数据的人，都能这样插队到你前面。即使最开始的读数据的人已经完成离开了，但还有新的人正在读数据。如此，你就一直无法获取到写数据的排他锁。</li>
</ul>
<p>这种情况，我们称之为：<strong>饿死（Starvation）</strong>。</p>
<p>避免这样的“插队”问题，也是很简单的——遵守“先来后到”的规则就好。具体如下。</p>
<p>当事务T请求数据Q的M型锁时，并发控制管理器授权加锁的条件是：</p>
<ul>
<li>此时，数据Q上没有与M不兼容的锁</li>
<li>此时，不存在 “正在等待加锁的” 且 “排队在事务T之前的” 的事务。</li>
</ul>
<hr>
<h4 id="二相锁协议"><a href="#二相锁协议" class="headerlink" title="二相锁协议"></a>二相锁协议</h4><blockquote>
<p>在 two-phase locking protocol 中：释放锁不必须在事务结束时进行。</p>
</blockquote>
<p>二相锁协议是<strong>能保证调度可序列化的</strong>。它要求每个事务分两个阶段提出加锁、解锁的申请：</p>
<ul>
<li><strong>growing phase</strong>：事务只能获得锁。</li>
<li><strong>shrinking phase</strong>：事务只能释放锁。</li>
</ul>
<p>例如下图中：T1 和 T2 就不是二相锁，T3 和 T4 就是二相锁。（且将<code>unlock(B)</code>提前到<code>lock-X(A)</code>后面执行，也仍是遵守协议的）</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example2.png" alt="example2"></p>
<p>对于任何事务，它获得它的最后一个锁的时候，也就是增长阶段结束的时候，我们称之为：事务的<strong>封锁点（lock point）</strong>。</p>
<p>二相锁是可序列化的，且：<strong>各个事务实际上就是按照 lock point 的先后进行顺序执行完成的。</strong></p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/two-phase.png" alt="two phase lock"></p>
<p>但二相锁并不是完美的：</p>
<ul>
<li>二相锁<strong>不能避免死锁</strong>的问题。</li>
<li>二项锁<strong>不是无级联的</strong>。它仍然可能出现级联回滚（cascading roll back）的情况。</li>
</ul>
<p>为了避免级联回滚，我们可以提出更严格的二相锁协议：</p>
<ul>
<li><strong>Strict two-phase locking protocol</strong>：一个事务必须持有 <em>所有的排他锁</em> 直到它提交或中止。</li>
<li><strong>Rigorous two-phase locking protocol</strong>：一个事务必须持有 <em>所有锁</em> 直到它提交或中止。</li>
</ul>
<p>其中后者的序列化的顺序是按照事务的提交时间（而不再是lock point）。</p>
<hr>
<h4 id="锁的转换"><a href="#锁的转换" class="headerlink" title="锁的转换"></a>锁的转换</h4><p>共享锁和排他锁时可以相互转换的，通过<strong>升级（upgrading）</strong>和<strong>降级（downgrading）</strong>。</p>
<p>例如：当事务T已经拥有S锁，且又需要X锁时：它可以将S锁升级成X锁。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/conversion.png" alt="conversion"></p>
<p>但锁的升级和降级不是能乱来的：</p>
<ul>
<li>升级只能发生在 growing phase</li>
<li>降级只能发生在 shrinking phase</li>
</ul>
<p>且进行锁转换时也需要注意：是否与当前已有的锁兼容。若不兼容，则需要等待。</p>
<p>所以，当一个事务需要锁时，并不是直接申请，而是先检查是否已有锁。若有，则请求升级或者降级；若无，再申请加锁。</p>
<blockquote>
<p>大部分数据库都采用 Strict two-phase locking protocol 和 lock conversion 的机制。</p>
</blockquote>
<hr>
<h4 id="锁管理器"><a href="#锁管理器" class="headerlink" title="锁管理器"></a>锁管理器</h4><p>锁管理器（lock manager）就是一个<strong>进程</strong>，并维护一个记录已有锁和等待锁的数据结构——<strong>锁表（lock table）</strong>。各个事务向其发送加锁、解锁的请求。</p>
<p>锁表结构如下图所示：</p>
<ul>
<li>用哈希链表存储各个数据项17、123、1912、14、144</li>
<li>某一个数据项上的锁，存储在指向当前数据项的链表中。第一个是被授权的锁，后续的是正在等待的锁。</li>
<li>例如：T2 申请 “数据123” 上的排他锁，此时 T1 和 T8 已持有其共享锁。那么 T2 的申请会被添加到 “数据123” 的链表的末尾。</li>
<li>如果一个事务终止（aborted），锁管理器会释放该事务持有的所有锁。</li>
</ul>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/lock-table.png" alt="lock table"></p>
<hr>
<h3 id="多粒度"><a href="#多粒度" class="headerlink" title="多粒度"></a>多粒度</h3><p>截至目前，我们讨论的并发控制都是以一个个数据为单位，但实际情况中，一个事务可能请求访问整个数据库的内容，这时一个个数据的上锁会非常耽误时间，我们希望能直接一次请求就能锁住整个数据库。所以，我们需要根据各种数据项大小，定义数据粒度的层次。</p>
<p><strong>多粒度机制（Multiple granularity mechanism）</strong>允许数据项具有不同的大小，并定义一个数据粒度的层次结构，其中较小的粒度嵌套在较大的粒度之内。这样的层次结构可以用树状图形来表示。树中的每个节点都可以单独加锁。当一个事务显式地锁定树中的一个节点时，它隐式地以相同的模式锁定该节点的所有子孙节点。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/tree.png" alt="granularity"></p>
<p>但是，每一次加锁，都需要判定当前节点是否能加锁。例如：事务 T1 想给 A1 加共享锁，但是系统必须检查 A1 的所有子节点中是否有排他锁。若有，则不能加锁。但如果每次加锁都需要搜索整个树，就违背了多粒度机制的初衷——快速地给大量数据加锁。</p>
<p>所以我们引入了一种新的锁的模式：<strong>意向锁（intention lock mode）</strong>。</p>
<hr>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><blockquote>
<p>意向锁也是可能出现死锁的。</p>
</blockquote>
<p>意向锁有五种锁的模式：</p>
<ul>
<li>S（共享锁）</li>
<li>X（排他锁）</li>
<li><strong>IS（共享意向锁）</strong>：表明将要在更低层次加共享锁。</li>
<li><strong>IX（排他意向锁）</strong>：表明将要在更低层次加排他锁。</li>
<li><strong>SIX（共享排他意向锁）</strong>：表明在更高层次加了共享锁，并且将要在更低层次加独占锁。（SIX &#x3D; S + IX）</li>
</ul>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/intention-lock.png" alt="intention lock"></p>
<p>核心想法就是：增加 IS、IX、SIX 模式，来反映子节点的上锁情况。这样给当前节点上锁时，就不必搜索当前节点的子树，检查当前节点的锁就能知道其子节点的上锁情况。当我们给一个节点上意向锁时，我们只需要更新当前节点和其父节点的锁即可，不需要更改其子节点的锁。</p>
<p>事务 T<sub>i</sub> 可以使用以下规则锁定节点 Q：</p>
<ul>
<li>必须遵守上图种的锁兼容矩阵。</li>
<li>必须首先锁定树的根节点，并且可以以任何模式锁定。</li>
<li>事务 T<sub>i</sub> 只有在 Q 的父节点被 T<sub>i</sub> 以 IX 或 IS 模式锁定时，才能以 S 或 IS 模式锁定节点 Q。</li>
<li>事务 T<sub>i</sub> 只有在 Q 的父节点被 T<sub>i</sub> 以 IX 或 SIX 模式锁定时，才能以 X、SIX 或 IX 模式锁定节点 Q。</li>
<li>事务 T<sub>i</sub> 只有在之前没有解锁过任何节点的情况下才能锁定节点（即：T<sub>i</sub> 遵循二相锁协议）。</li>
<li>事务 T<sub>i</sub> 只有在 Q 的子节点都没有被 T<sub>i</sub> 锁定的情况下才能解锁节点 Q。</li>
</ul>
<p>请注意：锁定是从根到叶节点的顺序进行的，而解锁是从叶到根的顺序进行的。</p>
<p>举例说明一下，假设依次发生以下请求：</p>
<ul>
<li><p>事务 T<sub>1</sub> 读取记录 r<sub>a<sub>1</sub></sub> 。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example3.1.png" alt="example3.1"></p>
</li>
<li><p>事务 T<sub>2</sub> 更新记录 r<sub>a<sub>2</sub></sub> 。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example3.2.png" alt="example3.2"></p>
</li>
<li><p>事务 T<sub>3</sub> 读取文件 F<sub>a</sub> 。（但此时 S<sub>T<sub>3 </sub></sub> 锁和 IX<sub>T<sub>2</sub></sub> 锁相矛盾了，所以 T<sub>3</sub> 会进行等待）</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example3.3.png" alt="example3.3"></p>
</li>
</ul>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>之前基于锁的各种协议，最终可序列化的顺序都是由上锁的时刻决定。现在我们介绍第二种实现并行控制的方法：<strong>基于时间戳的协议（Timestamp-Based Protocols）</strong>。这种方法的事务可序列化顺序是预先决定的。</p>
<hr>
<h4 id="事务时间戳"><a href="#事务时间戳" class="headerlink" title="事务时间戳"></a>事务时间戳</h4><p>每个事务 T<sub>i</sub> 都会被分配一个唯一的固定时间戳 TS(T<sub>i</sub>)。这个时间戳在事务 T<sub>i</sub> 开始执行之前由数据库系统分配。</p>
<ul>
<li><p>如果事务 T<sub>i</sub> 被分配了时间戳 TS(T<sub>i</sub>)，并且有一个新的事务 T<sub>j</sub> 进入系统，那么 TS(T<sub>i</sub>) &lt; TS(T<sub>j</sub>)。</p>
</li>
<li><p>有两种简单的方法来实现时间戳方案：</p>
<ul>
<li><p>使用<strong>系统时钟</strong>的值作为时间戳——事务的时间戳等于事务进入系统时的时钟值。</p>
</li>
<li><p>使用<strong>逻辑计数器</strong>，该计数器在分配新时间戳后递增——事务的时间戳等于事务进入系统时计数器的值。</p>
</li>
</ul>
</li>
</ul>
<p><strong>时间戳决定了可串行化的顺序</strong>。</p>
<ul>
<li>如果 TS(T<sub>i</sub>) &lt; TS(T<sub>j</sub>)，则生成度必须等效于一个串行调度，其中 T<sub>i</sub> 出现在事务 T<sub>j</sub> 之前。</li>
</ul>
<hr>
<h4 id="数据时间戳"><a href="#数据时间戳" class="headerlink" title="数据时间戳"></a>数据时间戳</h4><p>为了实现这个方案，协议为每个数据项 Q 维护两个时间戳值：</p>
<ul>
<li>**W-timestamp(Q)**：成功执行写操作 write(Q) 的任意事务的最大时间戳。</li>
<li>**R-timestamp(Q)**：成功执行读操作 read(Q) 的任意事务的最大时间戳。</li>
</ul>
<p>当新的指令（read(Q) 或 write(Q)）执行时，时间戳会被更新。</p>
<hr>
<h4 id="时间戳协议"><a href="#时间戳协议" class="headerlink" title="时间戳协议"></a>时间戳协议</h4><p>时间戳排序协议确保：<strong>任何冲突的读写操作按照时间戳顺序执行</strong>。</p>
<p>假设事务 T<sub>i</sub> 执行一个<strong>读操作</strong> read(Q)：</p>
<ul>
<li><p>如果 TS(T<sub>i</sub>) &lt; W-timestamp(Q)，那么 T<sub>i</sub> 需要读取一个已被后续事务覆盖的数据值。因此，读操作会被拒绝，并且 T<sub>i</sub> 将被回滚。</p>
</li>
<li><p>如果 TS(T<sub>i</sub>) ≥ W-timestamp(Q)，则读操作会被执行，并且 R-timestamp(Q) 被设置为 R-timestamp(Q) 和 TS(T<sub>i</sub>) 中的最大值。</p>
</li>
</ul>
<p>假设事务 执行一个<strong>写操作</strong> write(Q)：</p>
<ul>
<li><p>如果 TS(T<sub>i</sub>) &lt; R-timestamp(Q)，则表示 T<sub>i</sub> 正想写一个已经被后续事务读取了的数据 Q 的值，但系统认为这个值不会再被产生。因此，写操作会被拒绝，并且 T<sub>i</sub> 将被回滚。</p>
</li>
<li><p>如果 TS(T<sub>i</sub>) &lt; W-timestamp(Q)，则表示 T<sub>i</sub> 尝试写入一个已经过时的 Q 的值。因此，这个写操作也会被拒绝，并且 T<sub>i</sub> 将被回滚。</p>
</li>
<li><p>否则，写操作会被执行，并且设置 W-timestamp(Q) &#x3D; TS(T<sub>i</sub>)。</p>
</li>
</ul>
<p>请注意：如果一个事务被回滚了，系统会重新给它分配一个时间戳，并重启它。</p>
<p>时间戳协议保证了所有事务按照时间戳的顺序执行完成。所以，<strong>在时间戳协议里，不会出现死锁</strong>。但是仍然可能出现饿死的情况：一系列短事务可能会不断的被重启，因为一些长事务一直在执行。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/time-stamp.png" alt="timestamp serializability"></p>
<hr>
<p>时间戳协议虽然避免了死锁的问题，但它<strong>不能避免级联</strong>，而且很可能<strong>不是可恢复的</strong>。</p>
<p>举例说明一下。假设事务 T<sub>i</sub> 中止（abort），但是事务 T<sub>j</sub> 已经读取了由 T<sub>i</sub> 写入的数据项：</p>
<ul>
<li>那么事务 T<sub>j</sub> 必须中止（abort）。如果允许 T<sub>j</sub> 先提交，那么该调度就不是可恢复的。</li>
<li>此外，任何已经读取了由 T<sub>j</sub> 写入的数据项的事务都必须中止（abort）。</li>
<li>这可能导致级联回滚，即一系列的事务被迫回滚。</li>
</ul>
<p>这个问题的核心在于：当数据项 Q 在“被事务 T<sub>j</sub> 写后”和“事务 T<sub>j</sub> 提交”之间的时间里，数据项 Q 并不是盖棺定论的，可能因事务 T<sub>j</sub> 的回滚而改变，但数据项 Q 又可能被其他事务读取。所以解决方法的核心也就是：让所有事务都等到数据盖棺定论的时候再读取。</p>
<p>常见解决方法有以下三种：</p>
<ul>
<li>在事务结束时一次性执行所有写操作。</li>
<li>延迟读取未提交数据项，直到更新该数据项的事务已提交为止。</li>
<li>跟踪未提交的写操作，只允许事务 T<sub>i</sub> 在读取的值都是由已提交事务写入后才能提交（即提交依赖）。</li>
</ul>
<hr>
<h4 id="Thomas-写规则"><a href="#Thomas-写规则" class="headerlink" title="Thomas 写规则"></a>Thomas 写规则</h4><p>在时间戳协议的基础上，我们可以进一步增强数据库系统的并行能力。</p>
<p>考虑下图中的例子：事务 T<sub>27 </sub> 因为 <code>write(Q)</code> 操作被迫回滚。但实际上，按照“事务 T<sub>27 </sub> 先执行，事务 T<sub>28</sub> 后执行”的顺序，事务 T<sub>27</sub> 的 <code>write(Q)</code> 操作实际上会被事务 T<sub>28</sub> 的 <code>write(Q)</code> 操作覆盖掉。也就是说：事务 T<sub>27</sub> 的 <code>write(Q)</code> 操作根本没必要执行，事务 T<sub>27</sub> 也不必回滚。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/example4.png" alt="example4"></p>
<p><strong>对于过时的写操作，我们进行忽略</strong>。于是有了 <strong>Thomas’ Write Rule</strong>。</p>
<p>假设事务 T<sub>i</sub> 发出写操作 write(Q)。</p>
<ol>
<li>如果 TS(T<sub>i</sub>) &lt; R-timestamp(Q)：则表示 T<sub>i</sub> 正在更新一个已经被后续事务读取了的 Q，而系统曾假定这个值不会再被产生。因此，系统拒绝写操作，并回滚事务 T<sub>i</sub>。（与原协议相同）</li>
<li>如果 TS(T<sub>i</sub>) &lt; W-timestamp(Q)：则表示 T<sub>i</sub> 尝试写入一个过时的 Q 的值。根据修改后的规则，这个写操作可以被忽略。<strong>（新规则）</strong></li>
<li>否则：系统执行写操作，并将 W-timestamp(Q) 设置为 TS(T<sub>i</sub>)。（与原协议相同）</li>
</ol>
<hr>
<h4 id="（视图）可序列化"><a href="#（视图）可序列化" class="headerlink" title="（视图）可序列化"></a>（视图）可序列化</h4><p>通过忽略过时的写操作，Thomas 的写入规则允许产生：<strong>不符合冲突可串行化但是正确的</strong>调度。这就促使我们定义一种新的可序列化：视图可串行化。</p>
<p>如果两个调度 S 和 S’ 包含相同的一组事务，并且满足以下三个条件，那么它们被称为<strong>视图等价</strong>。</p>
<blockquote>
<p>第1、2条件保证了相同的值和计算。第2、3个条件保证了相同的最终状态。</p>
</blockquote>
<ul>
<li><strong>对于每个数据项 Q</strong>，如果事务 T<sub>i</sub> 在调度 S 中读取了 Q 的初始值，则在调度 S’ 中，事务 T<sub>i</sub> 也必须读取 Q 的初始值。<strong>（确保读取相同的初始值）</strong></li>
<li><strong>对于每个数据项 Q</strong>，如果事务 T<sub>i</sub> 在调度 S 中执行了 read(Q) 操作，并且这个值是由事务 T<sub>j</sub> 执行的 write(Q) 操作产生的，则在调度 S’ 中，事务 T<sub>i</sub> 也必须读取到由同一个事务 T<sub>j</sub> 执行的 write(Q) 操作产生的值。<strong>（确保读取由同一事务写入的值）</strong></li>
<li><strong>对于每个数据项 Q</strong>，在调度 S 中执行最终的 write(Q) 操作的事务（如果有的话），在调度 S’ 中也必须执行最终的 write(Q) 操作。<strong>（确保执行相同的最终写操作）</strong></li>
</ul>
<p>如果它与某个串行调度视图等价，调度 S 是<strong>视图可串行化（View Serializable）</strong>的。</p>
<p><img src="/2024/06/13/%E6%95%B0%E6%8D%AE%E5%BA%932-%E5%B9%B6%E8%A1%8C%E6%8E%A7%E5%88%B6/view-serializability.png" alt="View Serializability"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">数据库笔记1：Transaction</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-09 20:44:52" itemprop="dateCreated datePublished" datetime="2024-06-09T20:44:52+08:00">2024-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-19 15:06:12" itemprop="dateModified" datetime="2024-09-19T15:06:12+08:00">2024-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Database/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/06/09/数据库1-事务/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在实际场景中，数据库并不是完全可靠的。数据库可能在执行某些操作时崩了，导致一系列操作戛然而止。但有很多操作是必须一起执行的，比如银行转账，不能只执行从A账户扣钱，但不继续执行向B账户里加钱，这样会破坏数据一致性。</p>
<p>为了保证数据库在出现故障时，仍能保证数据的正确，我们引入了“事务”。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote>
<p>A transaction is a unit of program execution that  accesses and possibly updates various data items.</p>
</blockquote>
<p>总的来说，<strong>事务（transaction）</strong>是一种机制，用来确保多个操作（如读取和写入数据）要么全部成功，要么全部失败，从而保持数据的一致性和完整性。事务中的所有操作作为一个整体，要么全部完成（提交），要么全部撤销（回滚），因此保证了数据在任何情况下都是一致的。</p>
<hr>
<h4 id="ACID性质"><a href="#ACID性质" class="headerlink" title="ACID性质"></a>ACID性质</h4><p>在数据库系统中，Transaction需要保持一下四个性质（ACID properties）：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务中的操作，要么全部执行，要么全部没执行。</li>
<li><strong>一致性（Consistency）</strong></li>
<li><strong>隔离性（Isolation）</strong></li>
<li><strong>永久性（Durability）</strong>：事务成功完成后，即使系统出现故障，它对数据库所做的更改也会持久存在。</li>
</ul>
<p>通俗地讲，一致性是指，在仅当前事务执行时（没有事务并发执行），<strong>数据库中的某些不变量要保持一致</strong>。比如银行转账时两个账户的余额之和要保持不变。（英文释义：If a transaction is run atomically in isolation starting  from a consistent database, the database must again be  consistent at the end of the transaction. ）</p>
<p>但是，像银行转账，先从A账户扣钱，再向B账户里转钱，必然有处于不一致状态的时候。执行一个事务时也是如此。我们必须保证：<strong>不一致状态是不可见的</strong>。这也是为什么要保证原子性——要么全做完，要么回退到全部没做，不能位于中间不一致状态。</p>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/consistent.png" alt="consistency"></p>
<p>原子性一般这样实现：数据库会记录一个事务对任何数据进行写操作前的旧值。 这些信息被写入一个称为<strong>日志（log）</strong>的文件中。如果事务没有完成其执行，数据库系统会从日志中恢复旧值，使其看起来像事务从未执行过一样。而且日志记录需要发生在事务开始修改数据库之前（log records need to be written to stable storage before any  changes are made to the database on disk.）</p>
<p>诚然，事务序列运行（serially）是更容易实现的，但多个事务的并发运行能显著地提升性能，就像“一个人干活 Vs 一群人同时干活”：</p>
<ul>
<li>提升吞吐量和资源利用</li>
<li>减少事务等待时间</li>
</ul>
<p>但是，如果多个事务并发执行，它们的操作可能以某种不理想的方式交错进行，导致数据库处于不一致的状态。这就需要隔离性（保证隔离性才能实现并行控制）。</p>
<p>隔离性是指，多个事务可能并发执行，数据库要保证：</p>
<ul>
<li>对于任意两个事务 T<sub>i</sub> 和 T<sub>j</sub> 来说，T<sub>i</sub> <em>看起来</em> 要么是 T<sub>j</sub> 在 T<sub>i</sub> 开始之前就已经完成了执行，要么是 T<sub>j</sub> 在 T<sub>i</sub> 完成之后才开始执行。</li>
</ul>
<p>从而实现，每个事务都不知道系统中同时执行的其他事务。</p>
<hr>
<h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>为了跟准确地描述一个事务执行了多少，我们引入事务状态。</p>
<ul>
<li>Active：初始状态，事务在执行过程中处于该状态。</li>
<li>Partially committed：在执行了最后一个语句之后，事务进入该状态。</li>
<li>Failed：在发现正常执行无法继续后，事务进入该状态。</li>
<li>Aborted：在事务被回滚（roll back）且数据库恢复到事务开始之前的状态后，事务进入中止状态。</li>
<li>Committed：在当前事务成功完成执行后，事务进入该状态。</li>
</ul>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/state.png" alt="states"></p>
<p>特别地，我们需要小心：可观察的外部写操作（比如写入用户的屏幕，一旦发生，就不能撤销）。大多数系统允许这种写操作仅在事务进入Committed状态后才进行。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p><strong>调度（Schedule）</strong>是指一系列指令，并指定并发事务的指令在系统中执行的时间顺序。</p>
<p>且一个调度要满足：</p>
<ul>
<li>对于一组事务的调度必须包含这些事务中的所有指令。</li>
<li>必须保持各个事务中指令的相对顺序（</li>
<li>成功完成执行的事务，其最后一个语句将是commit指令。</li>
<li>未成功完成执行的事务，其最后一个语句将是abort指令。</li>
</ul>
<p>举一个例子：T1事务是从A转账50元到B，T2事务是A转账10%到B。下图的调度1是一个<strong>序列化的（serial）</strong>调度。</p>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/schedule1.png" alt="schedule1"></p>
<hr>
<h4 id="可序列化"><a href="#可序列化" class="headerlink" title="可序列化"></a>可序列化</h4><blockquote>
<p>等价（equivalent）有很多种，因此对应的可序列化（Serializable）也有多种。这里我们指的都是冲突等价和冲突可序列化。</p>
</blockquote>
<p>如果一个调度是等价于一个序列调度，则称为<strong>可序列化的（serializable）</strong>。所谓等价，通俗地讲，则是两个调度的最终结果相同。之后我们会给出严格定义。</p>
<p>下图中，调度3与调度1等价，是可序列化的调度。</p>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/schedule3.png" alt="schedule3"></p>
<p>我们只关心read和write两类操作，特别是它们执行的先后顺序，忽略其他类型的操作。大多数时候出问题都是因为：最新值还未写入数据库，而另一事务已经提前读取或写入了数据。但需要指出的是：可能存在两个调度，它们产生相同的结果，但它们不是冲突等价的（相当于是“充分条件，但不必要”）。</p>
<p>我们考虑调度 S 中的两个连续的指令 I 、 J 。</p>
<p>如果 I 、 J 分别作用于不同的数据，那么它们的先后顺序不影响数据结果，怎么样都可以，不冲突。</p>
<p>如果 I 、 J 分别作用于同一个数据 Q ，那么有4种可能情况：</p>
<ul>
<li><p>I &#x3D; read(Q), J &#x3D; read(Q) </p>
</li>
<li><p>I &#x3D; read(Q), J &#x3D; <strong>write(Q)</strong> </p>
</li>
<li><p>I &#x3D; <strong>write(Q)</strong>, J &#x3D; read(Q) </p>
</li>
<li><p>I &#x3D; <strong>write(Q)</strong>, J &#x3D; <strong>write(Q)</strong></p>
</li>
</ul>
<p> I 、 J 同时读取一个数据并不在意顺序，不冲突。但是 I 、 J 只要有至少一个是write操作，就会<strong>冲突（conflict）</strong>，需要考虑其执行顺序。</p>
<p>从而我们可以严格的定义等价：</p>
<p>如果一个调度 S 可以通过一系列非冲突指令的交换转换为另一个调度 S’，我们称 S 和 S’ 是<strong>冲突等价（Conflict Equivalent）</strong>的。</p>
<hr>
<h4 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h4><blockquote>
<p>Transaction T<sub>j</sub> is <strong>dependent</strong> on T<sub>i</sub>  means that T<sub>j</sub> has read data written by T<sub>i</sub> .</p>
</blockquote>
<p>到目前为止，我们都在假定事务不会失败的情况下讨论，但实际情况是事务失败总会发生。为了保证原子性，我们就必须撤销该事务的所有操作。但如果T<sub>i</sub> 失败了，且 T<sub>j</sub> 依赖于 T<sub>i</sub> ，那么我们需要也将 T<sub>j</sub> 撤销。 </p>
<p>例如下图中，调度9中的T<sub>7</sub>使用了T<sub>6</sub>写入的A值，如果T<sub>6</sub>结果出问题，则T<sub>7</sub>结果也有问题。所以，T<sub>7</sub>依赖于T<sub>6 </sub> 。</p>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/schedule9.png" alt="schedule9"></p>
<p><strong>可恢复调度（recoverable schedule）</strong>应当满足：</p>
<ul>
<li>如果一个事务 T<sub>j</sub> 读取了之前由事务 T<sub>i</sub> 写入的数据项，那么事务 T<sub>i</sub> 将在事务 T<sub>j</sub> 提交之前提交。</li>
</ul>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/recoverable.png" alt="recoverable"></p>
<p>可恢复性确保了：如果一个事务要用其他事务的数据项，则一定用的是最终数据，而不是过程中的数据。这样避免了一个数据出错导致一系列数据出错（级联效应）。</p>
<hr>
<h4 id="无级联的"><a href="#无级联的" class="headerlink" title="无级联的"></a>无级联的</h4><p>像上面所所的，一个事务的失败可能触发一系列事务的回滚。这种情况称为<strong>级联回滚（cascading rollback）</strong>。这样的情况会大大降低数据库的性能。</p>
<p>所以我们希望调度是<strong>无级联的（cascadeless）</strong>，亦即：</p>
<ul>
<li>任意一对事务 T<sub>i</sub> 和 T<sub>j</sub> ，如果一个事务 T<sub>j</sub> 读取了之前由事务 T<sub>i</sub> 写入的数据项，那么事务 T<sub>i</sub> 将在事务 T<sub>j</sub> 提交之前提交。</li>
</ul>
<p><img src="/2024/06/09/%E6%95%B0%E6%8D%AE%E5%BA%931-%E4%BA%8B%E5%8A%A1/cascadeless.png" alt="cascadeless"></p>
<p>不难发现，无级联则可恢复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">Block Nested Loop Join</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-06 19:05:36" itemprop="dateCreated datePublished" datetime="2024-06-06T19:05:36+08:00">2024-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-19 15:06:14" itemprop="dateModified" datetime="2024-09-19T15:06:14+08:00">2024-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/The-Introduction-to-Database/" itemprop="url" rel="index"><span itemprop="name">The Introduction to Database</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/06/06/数据库实验/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在数据库中，join 是经常使用的操作，但其工作量也可能是很大的。那么如何高效地完成 join 操作呢？</p>
<p>这篇 blog 将介绍：</p>
<ul>
<li>常见的 join 实现方式</li>
<li>如何在 Postgresql 源代码中实现 block nested loop join</li>
</ul>
<h3 id="常见-join-算法"><a href="#常见-join-算法" class="headerlink" title="常见 join 算法"></a>常见 join 算法</h3><h4 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h4><p>简单来说，Simple Nested-Loop Join 就是一个双层 for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果。</p>
<p>用伪代码描述大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (each tuple i in outer relation) &#123;</span><br><span class="line">	<span class="keyword">for</span> (each tuple j in inner relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (join_condition(tuple i, tuple j) is <span class="literal">true</span>)</span><br><span class="line">      		emit (tuple i, tuple j)</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">      		<span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<p>Nested-Loop Join 简单粗暴容易理解，就是通过双层循环比较数据来获得结果，但是这种算法显然太过于粗鲁，如果每个表有1万条数据，那么对数据比较的次数&#x3D;1万 * 1万 &#x3D; 1亿次，很显然这种查询效率会非常慢。</p>
<p>当然，数据库肯定不会这么粗暴地 join，所以就出现了后面的两种对Nested-Loop Join 优化算法。在执行 join 查询时，数据库会根据情况选择后面的两种 join 优化算法的进行join查询。</p>
<hr>
<h4 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h4><p>Index Nested-Loop Join 的优化思路主要是：减少内层表数据的匹配次数。</p>
<p>简单来说，Index Nested-Loop Join 就是通过外层表匹配条件，直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数，从原来的 “匹配次数&#x3D;外层表行数 * 内层表行数”，变成了 “外层表的行数 * 内层表索引的高度”，极大的提升了 join 的性能。</p>
<p><img src="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/Index-Nested-Loop-Join.jpg" alt="Index Nested-Loop Join"></p>
<p><strong>但是</strong>，Index Nested-Loop Join 算法的前提是：匹配的字段必须建立了索引。</p>
<hr>
<h4 id="Block-Nested-Loop-join"><a href="#Block-Nested-Loop-join" class="headerlink" title="Block Nested-Loop join"></a>Block Nested-Loop join</h4><p>Block Nested-Loop Join 其优化思路是：减少内层表的扫表次数。</p>
<p>Block Nested-Loop Join 算法意在通过一次性缓存外层表的多条数据，以此来减少内层表的扫表次数，从而达到提升性能的目的。</p>
<p><img src="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/Block-Nested-Loop-Join.jpg" alt="Block Nested-Loop Join"></p>
<p>如果无法使用 Index Nested-Loop Join 时候，一般都会使用 Block Nested-Loop Join 算法。</p>
<h3 id="PostgreSQL-实验"><a href="#PostgreSQL-实验" class="headerlink" title="PostgreSQL 实验"></a>PostgreSQL 实验</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol>
<li><p>下载 postgresql 源代码：</p>
<p><a target="_blank" rel="noopener" href="https://www.postgresql.org/ftp/source/v12.0/">https://www.postgresql.org/ftp/source/v12.0/</a></p>
</li>
<li><p>在本地编译并安装 postgresql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到源代码目录</span></span><br><span class="line"><span class="built_in">cd</span> postgresql-12.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 make 配置</span></span><br><span class="line">/configure --enable-depend --enable-cassert --enable-debug CFLAGS=<span class="string">&quot;-O0&quot;</span> --prefix=<span class="variable">$HOME</span>/pgsql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装(一般会安装到$HOME/pgsql)</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化本地 postgresql 服务器：</p>
<blockquote>
<p>若你不幸把 pgsql 装到别的位置，把 <code>$HOME/pgsql</code> 替换成你安装的路径。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/pgsql/bin/initdb -D <span class="variable">$HOME</span>/pgsql/data --locale=C</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 postgresql 服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/[guanz]/pgsql/bin/pg_ctl -D /home/[guanz]/pgsql/data -l logfile start</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接 postgresql 服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/pgsql/bin/psql postgres</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 postgresql 服务器：</p>
<blockquote>
<p>“Ctrl + D” 和 <code>\q</code> 均可以退出 postgresql 命令行。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This command depends on your installation location, please modify it</span></span><br><span class="line">/home/[guanz]/pgsql/bin/pg_ctl -D /home/[guanz]/pgsql/data stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres<span class="operator">=</span># <span class="keyword">CREATE</span> DATABASE similarity;</span><br><span class="line">postgres<span class="operator">-</span># \c similarity</span><br><span class="line">postgres<span class="operator">-</span># \i <span class="operator">/</span>home<span class="operator">/</span>[guanz<span class="operator">/</span>data<span class="operator">/</span>]similarity_data.sql</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/select.png" alt="select_example"></p>
</li>
</ol>
<hr>
<h4 id="源代码解读"><a href="#源代码解读" class="headerlink" title="源代码解读"></a>源代码解读</h4><p>虽然源代码很多，但我们只关注以下几个文件：</p>
<ul>
<li>src&#x2F;backend&#x2F;executor&#x2F;nodeNestloop.c</li>
<li>src&#x2F;include&#x2F;executor&#x2F;nodeNestloop.h</li>
<li>src&#x2F;include&#x2F;nodes&#x2F;execnodes.h</li>
</ul>
<p>Nested-Loop 主要算法都在 nodeNestloop.c 中实现：</p>
<blockquote>
<p>其中 ExecNestLoop() 是执行嵌套循环连接，其余两个  ExecInitNestLoop() 和 ExecEndNestLoop() 则分别完成初始化和终止。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* xht03：</span></span><br><span class="line"><span class="comment">* ExecNestLoop 是迭代器函数，不是一次执行完所有循环，</span></span><br><span class="line"><span class="comment">* 而是每次循环时执行一次的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> TupleTableSlot *</span><br><span class="line"><span class="title function_">ExecNestLoop</span><span class="params">(PlanState *pstate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * xht03：</span></span><br><span class="line"><span class="comment">    * node 指的是查询计划树中的一个节点。</span></span><br><span class="line"><span class="comment">    * 在这段代码中，NestLoopState *node 是</span></span><br><span class="line"><span class="comment">    * 一个指向 NestLoopState 结构体的指针，</span></span><br><span class="line"><span class="comment">    * 这个结构体通常包含了执行Nested Loop Join 所需要的状态信息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NestLoopState *node = castNode(NestLoopState, pstate);</span><br><span class="line">	NestLoop   *nl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * xht03：</span></span><br><span class="line"><span class="comment">    * Plan 指的是查询计划，</span></span><br><span class="line"><span class="comment">    * 它是数据库查询优化器生成的一种数据结构，</span></span><br><span class="line"><span class="comment">    * 用于描述如何执行一个SQL查询。</span></span><br><span class="line"><span class="comment">    * 查询计划是由一系列的操作步骤（或称为操作符）组成的树状结构，</span></span><br><span class="line"><span class="comment">    * 每一个操作步骤都对应查询计划树中的一个节点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	PlanState  *innerPlan;</span><br><span class="line">	PlanState  *outerPlan;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * xht03：</span></span><br><span class="line"><span class="comment">    * slot 意为“槽”</span></span><br><span class="line"><span class="comment">    * outerTupleSlot和innerTupleSlot是用来：</span></span><br><span class="line"><span class="comment">    * 存储从外部/内部关系（或称为左/右表）获取的当前元组</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">	TupleTableSlot *outerTupleSlot;</span><br><span class="line">	TupleTableSlot *innerTupleSlot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接条件</span></span><br><span class="line">    <span class="comment">// 其他条件（比如：where后面跟的表达式）</span></span><br><span class="line">	ExprState  *joinqual;</span><br><span class="line">	ExprState  *otherqual;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储执行过程中的上下文</span></span><br><span class="line">	ExprContext *econtext;</span><br><span class="line">	ListCell   *lc;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 检查中断（不用管）</span></span><br><span class="line">	CHECK_FOR_INTERRUPTS();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get information from the node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ENL1_printf(<span class="string">&quot;getting info from node&quot;</span>);</span><br><span class="line"></span><br><span class="line">	nl = (NestLoop *) node-&gt;js.ps.plan;</span><br><span class="line">	joinqual = node-&gt;js.joinqual;</span><br><span class="line">	otherqual = node-&gt;js.ps.qual;</span><br><span class="line">	outerPlan = outerPlanState(node);	<span class="comment">// 记录外表所在的tuple</span></span><br><span class="line">	innerPlan = innerPlanState(node);	<span class="comment">// 记录内表所在的tuple</span></span><br><span class="line">	econtext = node-&gt;js.ps.ps_ExprContext;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset per-tuple memory context to free any expression evaluation</span></span><br><span class="line"><span class="comment">	 * storage allocated in the previous tuple cycle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ResetExprContext(econtext);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, everything is setup for the join so now loop until we return a</span></span><br><span class="line"><span class="comment">	 * qualifying join tuple.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ENL1_printf(<span class="string">&quot;entering main loop&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * xht03:</span></span><br><span class="line"><span class="comment">		 * 当需要新的外部元组时，获取下一个的外部元组，</span></span><br><span class="line"><span class="comment">		 * 并让内表从头开始扫描（重置）</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;nl_NeedNewOuter)</span><br><span class="line">		&#123;</span><br><span class="line">			ENL1_printf(<span class="string">&quot;getting new outer tuple&quot;</span>);</span><br><span class="line">			outerTupleSlot = ExecProcNode(outerPlan);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * xht03：</span></span><br><span class="line"><span class="comment">			 * 如果下一个外部元组为空，则 join 完成了</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (TupIsNull(outerTupleSlot))</span><br><span class="line">			&#123;</span><br><span class="line">				ENL1_printf(<span class="string">&quot;no outer tuple, ending join&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENL1_printf(<span class="string">&quot;saving new outer tuple information&quot;</span>);</span><br><span class="line">			econtext-&gt;ecxt_outertuple = outerTupleSlot;</span><br><span class="line">			node-&gt;nl_NeedNewOuter = <span class="literal">false</span>;</span><br><span class="line">			node-&gt;nl_MatchedOuter = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * fetch the values of any outer Vars that must be passed to the</span></span><br><span class="line"><span class="comment">			 * inner scan, and store them in the appropriate PARAM_EXEC slots.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * xht03：</span></span><br><span class="line"><span class="comment">			 * 传递一些参数，不用管，也不要改</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			foreach(lc, nl-&gt;nestParams)</span><br><span class="line">			&#123;</span><br><span class="line">				NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);</span><br><span class="line">				<span class="type">int</span>			paramno = nlp-&gt;paramno;</span><br><span class="line">				ParamExecData *prm;</span><br><span class="line"></span><br><span class="line">				prm = &amp;(econtext-&gt;ecxt_param_exec_vals[paramno]);</span><br><span class="line">				<span class="comment">/* Param value should be an OUTER_VAR var */</span></span><br><span class="line">				Assert(IsA(nlp-&gt;paramval, Var));</span><br><span class="line">				Assert(nlp-&gt;paramval-&gt;varno == OUTER_VAR);</span><br><span class="line">				Assert(nlp-&gt;paramval-&gt;varattno &gt; <span class="number">0</span>);</span><br><span class="line">				prm-&gt;value = slot_getattr(outerTupleSlot,</span><br><span class="line">										  nlp-&gt;paramval-&gt;varattno,</span><br><span class="line">										  &amp;(prm-&gt;isnull));</span><br><span class="line">				<span class="comment">/* Flag parameter value as changed */</span></span><br><span class="line">				innerPlan-&gt;chgParam = bms_add_member(innerPlan-&gt;chgParam,</span><br><span class="line">													 paramno);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * now rescan the inner plan</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ENL1_printf(<span class="string">&quot;rescanning inner plan&quot;</span>);</span><br><span class="line">			ExecReScan(innerPlan);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * we have an outerTuple, try to get the next inner tuple.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ENL1_printf(<span class="string">&quot;getting new inner tuple&quot;</span>);</span><br><span class="line"></span><br><span class="line">		innerTupleSlot = ExecProcNode(innerPlan);</span><br><span class="line">		econtext-&gt;ecxt_innertuple = innerTupleSlot;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TupIsNull(innerTupleSlot))</span><br><span class="line">		&#123;</span><br><span class="line">			ENL1_printf(<span class="string">&quot;no inner tuple, need new outer tuple&quot;</span>);</span><br><span class="line"></span><br><span class="line">			node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node-&gt;nl_MatchedOuter &amp;&amp;</span><br><span class="line">				(node-&gt;js.jointype == JOIN_LEFT ||</span><br><span class="line">				 node-&gt;js.jointype == JOIN_ANTI))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * We are doing an outer join and there were no join matches</span></span><br><span class="line"><span class="comment">				 * for this outer tuple.  Generate a fake join tuple with</span></span><br><span class="line"><span class="comment">				 * nulls for the inner tuple, and return it if it passes the</span></span><br><span class="line"><span class="comment">				 * non-join quals.</span></span><br><span class="line"><span class="comment">				 * </span></span><br><span class="line"><span class="comment">				 * xht03：</span></span><br><span class="line"><span class="comment">				 * 你可能也发现了：外部元组和内部元组的值，除了会存进 outerTupleSlot</span></span><br><span class="line"><span class="comment">				 * 和 innerTupleSlot，还要存进上下文 econtext 里。</span></span><br><span class="line"><span class="comment">				 * 这是因为：ExecQual() 判断是否满足等式条件的函数，是使用上下文中</span></span><br><span class="line"><span class="comment">				 * 存储的内外部元组信息进行判断的。</span></span><br><span class="line"><span class="comment">				 * 这样的函数还有很多，所以一定要记得更新上下文</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				econtext-&gt;ecxt_innertuple = node-&gt;nl_NullInnerTupleSlot;</span><br><span class="line"></span><br><span class="line">				ENL1_printf(<span class="string">&quot;testing qualification for outer-join tuple&quot;</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (otherqual == <span class="literal">NULL</span> || ExecQual(otherqual, econtext))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * qualification was satisfied so we project and return</span></span><br><span class="line"><span class="comment">					 * the slot containing the result tuple using</span></span><br><span class="line"><span class="comment">					 * ExecProject().</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					ENL1_printf(<span class="string">&quot;qualification succeeded, projecting tuple&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> ExecProject(node-&gt;js.ps.ps_ProjInfo);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					InstrCountFiltered2(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Otherwise just return to top of loop for a new outer tuple.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * at this point we have a new pair of inner and outer tuples so we</span></span><br><span class="line"><span class="comment">		 * test the inner and outer tuples to see if they satisfy the node&#x27;s</span></span><br><span class="line"><span class="comment">		 * qualification.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Only the joinquals determine MatchedOuter status, but all quals</span></span><br><span class="line"><span class="comment">		 * must pass to actually return the tuple.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ENL1_printf(<span class="string">&quot;testing qualification&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ExecQual(joinqual, econtext))</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;nl_MatchedOuter = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* In an antijoin, we never return a matched tuple */</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;js.jointype == JOIN_ANTI)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">continue</span>;		<span class="comment">/* return to top of loop */</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we only need to join to the first matching inner tuple, then</span></span><br><span class="line"><span class="comment">			 * consider returning this one, but after that continue with next</span></span><br><span class="line"><span class="comment">			 * outer tuple.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;js.single_match)</span><br><span class="line">				node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (otherqual == <span class="literal">NULL</span> || ExecQual(otherqual, econtext))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * qualification was satisfied so we project and return the</span></span><br><span class="line"><span class="comment">				 * slot containing the result tuple using ExecProject().</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				ENL1_printf(<span class="string">&quot;qualification succeeded, projecting tuple&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> ExecProject(node-&gt;js.ps.ps_ProjInfo);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				InstrCountFiltered2(node, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			InstrCountFiltered1(node, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Tuple fails qual, so free per-tuple memory and try again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ResetExprContext(econtext);</span><br><span class="line"></span><br><span class="line">		ENL1_printf(<span class="string">&quot;qualification failed, looping&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *		ExecInitNestLoop</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestLoopState *</span><br><span class="line"><span class="title function_">ExecInitNestLoop</span><span class="params">(NestLoop *node, EState *estate, <span class="type">int</span> eflags)</span></span><br><span class="line">&#123;</span><br><span class="line">	NestLoopState *nlstate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for unsupported flags */</span></span><br><span class="line">	Assert(!(eflags &amp; (EXEC_FLAG_BACKWARD | EXEC_FLAG_MARK)));</span><br><span class="line"></span><br><span class="line">	NL1_printf(<span class="string">&quot;ExecInitNestLoop: %s\n&quot;</span>,</span><br><span class="line">			   <span class="string">&quot;initializing node&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * create state structure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nlstate = makeNode(NestLoopState);</span><br><span class="line">	nlstate-&gt;js.ps.plan = (Plan *) node;</span><br><span class="line">	nlstate-&gt;js.ps.state = estate;</span><br><span class="line">	nlstate-&gt;js.ps.ExecProcNode = ExecNestLoop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Miscellaneous initialization</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * create expression context for node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ExecAssignExprContext(estate, &amp;nlstate-&gt;js.ps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * initialize child nodes</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If we have no parameters to pass into the inner rel from the outer,</span></span><br><span class="line"><span class="comment">	 * tell the inner child that cheap rescans would be good.  If we do have</span></span><br><span class="line"><span class="comment">	 * such parameters, then there is no point in REWIND support at all in the</span></span><br><span class="line"><span class="comment">	 * inner child, because it will always be rescanned with fresh parameter</span></span><br><span class="line"><span class="comment">	 * values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	outerPlanState(nlstate) = ExecInitNode(outerPlan(node), estate, eflags);</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;nestParams == NIL)</span><br><span class="line">		eflags |= EXEC_FLAG_REWIND;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		eflags &amp;= ~EXEC_FLAG_REWIND;</span><br><span class="line">	innerPlanState(nlstate) = ExecInitNode(innerPlan(node), estate, eflags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize result slot, type and projection.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ExecInitResultTupleSlotTL(&amp;nlstate-&gt;js.ps, &amp;TTSOpsVirtual);</span><br><span class="line">	ExecAssignProjectionInfo(&amp;nlstate-&gt;js.ps, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * initialize child expressions</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nlstate-&gt;js.ps.qual =</span><br><span class="line">		ExecInitQual(node-&gt;join.plan.qual, (PlanState *) nlstate);</span><br><span class="line">	nlstate-&gt;js.jointype = node-&gt;join.jointype;</span><br><span class="line">	nlstate-&gt;js.joinqual =</span><br><span class="line">		ExecInitQual(node-&gt;join.joinqual, (PlanState *) nlstate);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * detect whether we need only consider the first matching inner tuple</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nlstate-&gt;js.single_match = (node-&gt;join.inner_unique ||</span><br><span class="line">								node-&gt;join.jointype == JOIN_SEMI);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up null tuples for outer joins, if needed */</span></span><br><span class="line">	<span class="keyword">switch</span> (node-&gt;join.jointype)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> JOIN_INNER:</span><br><span class="line">		<span class="keyword">case</span> JOIN_SEMI:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> JOIN_LEFT:</span><br><span class="line">		<span class="keyword">case</span> JOIN_ANTI:</span><br><span class="line">			nlstate-&gt;nl_NullInnerTupleSlot =</span><br><span class="line">				ExecInitNullTupleSlot(estate,</span><br><span class="line">									  ExecGetResultType(innerPlanState(nlstate)),</span><br><span class="line">									  &amp;TTSOpsVirtual);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			elog(ERROR, <span class="string">&quot;unrecognized join type: %d&quot;</span>,</span><br><span class="line">				 (<span class="type">int</span>) node-&gt;join.jointype);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * finally, wipe the current outer tuple clean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	nlstate-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line">	nlstate-&gt;nl_MatchedOuter = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	NL1_printf(<span class="string">&quot;ExecInitNestLoop: %s\n&quot;</span>,</span><br><span class="line">			   <span class="string">&quot;node initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nlstate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *		ExecEndNestLoop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		closes down scans and frees allocated storage</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ExecEndNestLoop</span><span class="params">(NestLoopState *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	NL1_printf(<span class="string">&quot;ExecEndNestLoop: %s\n&quot;</span>,</span><br><span class="line">			   <span class="string">&quot;ending node processing&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Free the exprcontext</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ExecFreeExprContext(&amp;node-&gt;js.ps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * clean out the tuple table</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ExecClearTuple(node-&gt;js.ps.ps_ResultTupleSlot);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * close down subplans</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ExecEndNode(outerPlanState(node));</span><br><span class="line">	ExecEndNode(innerPlanState(node));</span><br><span class="line"></span><br><span class="line">	NL1_printf(<span class="string">&quot;ExecEndNestLoop: %s\n&quot;</span>,</span><br><span class="line">			   <span class="string">&quot;node processing ended&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *		ExecReScanNestLoop</span></span><br><span class="line"><span class="comment"> * ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ExecReScanNestLoop</span><span class="params">(NestLoopState *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	PlanState  *outerPlan = outerPlanState(node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If outerPlan-&gt;chgParam is not null then plan will be automatically</span></span><br><span class="line"><span class="comment">	 * re-scanned by first ExecProcNode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (outerPlan-&gt;chgParam == <span class="literal">NULL</span>)</span><br><span class="line">		ExecReScan(outerPlan);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * innerPlan is re-scanned for each new outer tuple and MUST NOT be</span></span><br><span class="line"><span class="comment">	 * re-scanned from here or you&#x27;ll get troubles from inner index scans when</span></span><br><span class="line"><span class="comment">	 * outer Vars are used as run-time keys...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line">	node-&gt;nl_MatchedOuter = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="源代码修改"><a href="#源代码修改" class="headerlink" title="源代码修改"></a>源代码修改</h4><p>我们主要做了一下修改：</p>
<ul>
<li>新增了结构体类型 <strong>NestedBlock</strong> ，用于存放中间缓存的外部元组。</li>
</ul>
<p>与之相应地：</p>
<ul>
<li>增加了 <strong>GetNestedBlock()</strong> 函数，用于获取新的中间元组。</li>
<li>在上下文类型 <strong>ExprContext</strong> 中增加 <strong>NestedBlock</strong> 变量，将中间缓存元组记录在上下文中。</li>
<li>修改 <strong>ExecNestLoop()</strong> 函数：外部元组一次取出至多 <strong>NESTED_BLOCK_SIZE</strong> 个元组放入缓存 <strong>NestedBlock</strong> 中，并照旧扫描内部元组。但每次需要将缓存中的所有 outer tuple 一一与 inner tuple 进行比较，且外部元组的指针需要往后移动 <strong>NESTED_BLOCK_SIZE</strong> 个元组。</li>
</ul>
<p>修改细节如下（修改之处都加有 <em>xht03</em> 注释）：</p>
<blockquote>
<p>execnodes.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xht03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NESTED_BLOCK_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NestedBlock</span>&#123;</span></span><br><span class="line">    TupleTableSlot *tuple[NESTED_BLOCK_SIZE];	<span class="comment">// 存放外部元组</span></span><br><span class="line">	<span class="type">bool</span> isMatched[NESTED_BLOCK_SIZE];			<span class="comment">// 是否在内部关系中匹配到过</span></span><br><span class="line">    <span class="type">int</span> size;									<span class="comment">// 缓存中的元组个数</span></span><br><span class="line">&#125; NestedBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ExprContext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	NodeTag		type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tuples that Var nodes in expression may refer to */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_SCANTUPLE 1</span></span><br><span class="line">	TupleTableSlot *ecxt_scantuple;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_INNERTUPLE 2</span></span><br><span class="line">	TupleTableSlot *ecxt_innertuple;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_OUTERTUPLE 3</span></span><br><span class="line">	TupleTableSlot *ecxt_outertuple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xht03</span></span><br><span class="line">	NestedBlock *ecxt_block;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Memory contexts for expression evaluation --- see notes above */</span></span><br><span class="line">	MemoryContext ecxt_per_query_memory;</span><br><span class="line">	MemoryContext ecxt_per_tuple_memory;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Values to substitute for Param nodes in expression */</span></span><br><span class="line">	ParamExecData *ecxt_param_exec_vals;	<span class="comment">/* for PARAM_EXEC params */</span></span><br><span class="line">	ParamListInfo ecxt_param_list_info; <span class="comment">/* for other param types */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Values to substitute for Aggref nodes in the expressions of an Agg</span></span><br><span class="line"><span class="comment">	 * node, or for WindowFunc nodes within a WindowAgg node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_AGGVALUES 8</span></span><br><span class="line">	Datum	   *ecxt_aggvalues; <span class="comment">/* precomputed values for aggs/windowfuncs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_AGGNULLS 9</span></span><br><span class="line">	<span class="type">bool</span>	   *ecxt_aggnulls;	<span class="comment">/* null flags for aggs/windowfuncs */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Value to substitute for CaseTestExpr nodes in expression */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_CASEDATUM 10</span></span><br><span class="line">	Datum		caseValue_datum;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_CASENULL 11</span></span><br><span class="line">	<span class="type">bool</span>		caseValue_isNull;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Value to substitute for CoerceToDomainValue nodes in expression */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_DOMAINDATUM 12</span></span><br><span class="line">	Datum		domainValue_datum;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELDNO_EXPRCONTEXT_DOMAINNULL 13</span></span><br><span class="line">	<span class="type">bool</span>		domainValue_isNull;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Link to containing EState (NULL if a standalone ExprContext) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EState</span> *<span class="title">ecxt_estate</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Functions to call back when ExprContext is shut down or rescanned */</span></span><br><span class="line">	ExprContext_CB *ecxt_callbacks;</span><br><span class="line">&#125; ExprContext;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nodeNestloop.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NODENESTLOOP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODENESTLOOP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nodes/execnodes.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// xht03</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">GetNestedBlock</span><span class="params">(NestedBlock *block, PlanState *outerPlan)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> NestLoopState *<span class="title function_">ExecInitNestLoop</span><span class="params">(NestLoop *node, EState *estate, <span class="type">int</span> eflags)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ExecEndNestLoop</span><span class="params">(NestLoopState *node)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ExecReScanNestLoop</span><span class="params">(NestLoopState *node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>							<span class="comment">/* NODENESTLOOP_H */</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>nodeNestloop.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xht03</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">GetNestedBlock</span><span class="params">(NestedBlock *block, PlanState *outerPlan)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NESTED_BLOCK_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        block-&gt;tuple[i] = ExecProcNode(outerPlan);</span><br><span class="line">		block-&gt;isMatched[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(TupIsNull(block-&gt;tuple[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            block-&gt;size = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TupleTableSlot *</span><br><span class="line"><span class="title function_">ExecNestLoop</span><span class="params">(PlanState *pstate)</span>	</span><br><span class="line">&#123;</span><br><span class="line">	NestLoopState *node = castNode(NestLoopState, pstate);</span><br><span class="line">	NestLoop   *nl;</span><br><span class="line">	PlanState  *innerPlan;</span><br><span class="line">	PlanState  *outerPlan;</span><br><span class="line">	TupleTableSlot *outerTupleSlot;</span><br><span class="line">	TupleTableSlot *innerTupleSlot;</span><br><span class="line">	ExprState  *joinqual;</span><br><span class="line">	ExprState  *otherqual;</span><br><span class="line">	ExprContext *econtext;</span><br><span class="line">	ListCell   *lc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// xht03</span></span><br><span class="line">	NestedBlock block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CHECK_FOR_INTERRUPTS();	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get information from the node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ENL1_printf(<span class="string">&quot;getting info from node&quot;</span>);</span><br><span class="line"></span><br><span class="line">	nl = (NestLoop *) node-&gt;js.ps.plan;</span><br><span class="line">	joinqual = node-&gt;js.joinqual;</span><br><span class="line">	otherqual = node-&gt;js.ps.qual;</span><br><span class="line">	outerPlan = outerPlanState(node);</span><br><span class="line">	innerPlan = innerPlanState(node);</span><br><span class="line">	econtext = node-&gt;js.ps.ps_ExprContext;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reset per-tuple memory context to free any expression evaluation</span></span><br><span class="line"><span class="comment">	 * storage allocated in the previous tuple cycle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ResetExprContext(econtext);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ok, everything is setup for the join so now loop until we return a</span></span><br><span class="line"><span class="comment">	 * qualifying join tuple.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ENL1_printf(<span class="string">&quot;entering main loop&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we don&#x27;t have an outer tuple, get the next one and reset the</span></span><br><span class="line"><span class="comment">		 * inner scan.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;nl_NeedNewOuter)</span><br><span class="line">		&#123;</span><br><span class="line">			ENL1_printf(<span class="string">&quot;getting new outer tuple&quot;</span>);</span><br><span class="line">			<span class="comment">// xht03</span></span><br><span class="line">			GetNestedBlock(&amp;block, outerPlan);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 	 * if there are no more outer tuples, then the join is complete..</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">// xht03</span></span><br><span class="line">			<span class="keyword">if</span> (block.size == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ENL1_printf(<span class="string">&quot;no outer tuple, ending join&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENL1_printf(<span class="string">&quot;saving new outer tuple information&quot;</span>);</span><br><span class="line">			<span class="comment">//econtext-&gt;ecxt_outertuple = outerTupleSlot;	// 记录外表所在的tuple，更新上下文</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// xht03</span></span><br><span class="line">			outerTupleSlot = block.tuple[block.size - <span class="number">1</span>];</span><br><span class="line">			econtext-&gt;ecxt_outertuple = outerTupleSlot;</span><br><span class="line">			econtext-&gt;ecxt_block = &amp;block;</span><br><span class="line">			node-&gt;nl_NeedNewOuter = <span class="literal">false</span>;</span><br><span class="line">			node-&gt;nl_MatchedOuter = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * fetch the values of any outer Vars that must be passed to the</span></span><br><span class="line"><span class="comment">			 * inner scan, and store them in the appropriate PARAM_EXEC slots.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">// 将外表的一些参数传递给内表</span></span><br><span class="line">			foreach(lc, nl-&gt;nestParams)</span><br><span class="line">			&#123;</span><br><span class="line">				NestLoopParam *nlp = (NestLoopParam *) lfirst(lc);</span><br><span class="line">				<span class="type">int</span>			paramno = nlp-&gt;paramno;</span><br><span class="line">				ParamExecData *prm;</span><br><span class="line">				prm = &amp;(econtext-&gt;ecxt_param_exec_vals[paramno]);</span><br><span class="line">				<span class="comment">/* Param value should be an OUTER_VAR var */</span></span><br><span class="line">				Assert(IsA(nlp-&gt;paramval, Var));</span><br><span class="line">				Assert(nlp-&gt;paramval-&gt;varno == OUTER_VAR);</span><br><span class="line">				Assert(nlp-&gt;paramval-&gt;varattno &gt; <span class="number">0</span>);</span><br><span class="line">				prm-&gt;value = slot_getattr(outerTupleSlot,</span><br><span class="line">										  nlp-&gt;paramval-&gt;varattno,</span><br><span class="line">										  &amp;(prm-&gt;isnull));</span><br><span class="line">				<span class="comment">/* Flag parameter value as changed */</span></span><br><span class="line">				innerPlan-&gt;chgParam = bms_add_member(innerPlan-&gt;chgParam,</span><br><span class="line">													 paramno);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * now rescan the inner plan</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">// 重新确定内表从哪里开始扫描</span></span><br><span class="line">			ENL1_printf(<span class="string">&quot;rescanning inner plan&quot;</span>);</span><br><span class="line">			ExecReScan(innerPlan);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * we have an outerTuple, try to get the next inner tuple.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ENL1_printf(<span class="string">&quot;getting new inner tuple&quot;</span>);</span><br><span class="line">		innerTupleSlot = ExecProcNode(innerPlan);		<span class="comment">// 获取新的内部节点（tuple）</span></span><br><span class="line">		econtext-&gt;ecxt_innertuple = innerTupleSlot;		<span class="comment">// 记录内表所在的tuple，更新上下文</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (TupIsNull(innerTupleSlot))</span><br><span class="line">		&#123;</span><br><span class="line">			ENL1_printf(<span class="string">&quot;no inner tuple, need new outer tuple&quot;</span>);</span><br><span class="line">			node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			* xht03:</span></span><br><span class="line"><span class="comment">			* If not all the tuples in the block have been matched,</span></span><br><span class="line"><span class="comment">			* or the join type is left-join or anti-join</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">if</span> (!node-&gt;nl_MatchedOuter &amp;&amp;</span><br><span class="line">				(node-&gt;js.jointype == JOIN_LEFT ||</span><br><span class="line">				 node-&gt;js.jointype == JOIN_ANTI))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * We are doing an outer join and there were no join matches</span></span><br><span class="line"><span class="comment">				 * for this outer tuple.  Generate a fake join tuple with</span></span><br><span class="line"><span class="comment">				 * nulls for the inner tuple, and return it if it passes the</span></span><br><span class="line"><span class="comment">				 * non-join quals.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; block.size; i++)&#123;</span><br><span class="line">					econtext-&gt;ecxt_outertuple = block.tuple[i];</span><br><span class="line">					<span class="keyword">if</span>(!block.isMatched[i])&#123;</span><br><span class="line">                        <span class="comment">// set to a empty tuple</span></span><br><span class="line">						econtext-&gt;ecxt_innertuple = node-&gt;nl_NullInnerTupleSlot;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 检查非连接条件（non-join quals）的其他条件是否满足</span></span><br><span class="line">						ENL1_printf(<span class="string">&quot;testing qualification for outer-join tuple&quot;</span>);</span><br><span class="line">						<span class="keyword">if</span> (otherqual == <span class="literal">NULL</span> || ExecQual(otherqual, econtext))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 	* qualification was satisfied so we project and return</span></span><br><span class="line"><span class="comment">						 	* the slot containing the result tuple using</span></span><br><span class="line"><span class="comment">						 	* ExecProject().</span></span><br><span class="line"><span class="comment">						 	*/</span></span><br><span class="line">							ENL1_printf(<span class="string">&quot;qualification succeeded, projecting tuple&quot;</span>);</span><br><span class="line">							<span class="keyword">return</span> ExecProject(node-&gt;js.ps.ps_ProjInfo);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							InstrCountFiltered2(node, <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Otherwise just return to top of loop for a new outer tuple.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * at this point we have a new pair of inner and outer tuples so we</span></span><br><span class="line"><span class="comment">		 * test the inner and outer tuples to see if they satisfy the node&#x27;s</span></span><br><span class="line"><span class="comment">		 * qualification.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Only the joinquals determine MatchedOuter status, but all quals</span></span><br><span class="line"><span class="comment">		 * must pass to actually return the tuple.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ENL1_printf(<span class="string">&quot;testing qualification&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 测试是否满足 join 条件</span></span><br><span class="line">		<span class="comment">// xht03</span></span><br><span class="line">		<span class="type">int</span> matched_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; block.size; i++)&#123;</span><br><span class="line">			econtext-&gt;ecxt_outertuple = block.tuple[i];</span><br><span class="line">			<span class="keyword">if</span> (ExecQual(joinqual, econtext))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//xht03</span></span><br><span class="line">				<span class="keyword">if</span>(!block.isMatched[i])&#123;</span><br><span class="line">					matched_num++;</span><br><span class="line">					block.isMatched[i] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* If we only need to join to the first matching inner tuple, then</span></span><br><span class="line"><span class="comment">				* consider returning this one, but after that continue with next</span></span><br><span class="line"><span class="comment">				* outer tuple.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> (otherqual == <span class="literal">NULL</span> || ExecQual(otherqual, econtext))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					* qualification was satisfied so we project and return the</span></span><br><span class="line"><span class="comment">					* slot containing the result tuple using ExecProject().</span></span><br><span class="line"><span class="comment">					*/</span></span><br><span class="line">					ENL1_printf(<span class="string">&quot;qualification succeeded, projecting tuple&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> ExecProject(node-&gt;js.ps.ps_ProjInfo);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					InstrCountFiltered2(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				InstrCountFiltered1(node, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* xht03:</span></span><br><span class="line"><span class="comment">		* If all tuples in the block have been matched</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span>(matched_num == block.size)</span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;nl_MatchedOuter = <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">/* In an antijoin, we never return a matched tuple */</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;js.jointype == JOIN_ANTI || node-&gt;js.single_match)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;nl_NeedNewOuter = <span class="literal">true</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Tuple fails qual, so free per-tuple memory and try again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ResetExprContext(econtext);</span><br><span class="line">		ENL1_printf(<span class="string">&quot;qualification failed, looping&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="源代码测试"><a href="#源代码测试" class="headerlink" title="源代码测试"></a>源代码测试</h4><p>重新编译并安装 postgresql 后，设置 NESTED_BLOCK_SIZE &#x3D; 1、2、8、64、128、1024，运行下面语句两次，取第二次运行时间。</p>
<blockquote>
<p>在数据库命令行中输入：<code>\timing</code>，打开测时间功能。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> restaurantaddress ra, restaurantphone rp <span class="keyword">WHERE</span> ra.name <span class="operator">=</span> rp.name;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/1024.png" alt="Timing"></p>
<table>
<thead>
<tr>
<th align="center">NESTED_BLOCK_SIZE</th>
<th align="center">时间1&#x2F;ms</th>
<th align="center">时间2&#x2F;ms</th>
<th align="center">时间3&#x2F;ms</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2.710</td>
<td align="center">2.559</td>
<td align="center">2.565</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2.579</td>
<td align="center">2.753</td>
<td align="center">2.636</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">2.337</td>
<td align="center">2.483</td>
<td align="center">2.716</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">2.277</td>
<td align="center">2.441</td>
<td align="center">1.896</td>
</tr>
<tr>
<td align="center">128</td>
<td align="center">2.657</td>
<td align="center">2.543</td>
<td align="center">2.464</td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">2.871</td>
<td align="center">2.743</td>
<td align="center">2.778</td>
</tr>
</tbody></table>
<p>这样的实验结果是符合预期的：</p>
<ul>
<li><strong>NESTED_BLOCK_SIZE</strong> 太小时，与 Simple Nested-Loop 相近；当 <strong>NESTED_BLOCK_SIZE</strong> 太大时，就相当于内外表互换后的 Simple Nested-Loop。所以当 <strong>NESTED_BLOCK_SIZE</strong> 取一个大小适中的值时，Block Nested-Loop 才能性能最大化。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xht03.github.io/2024/04/16/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xht03">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="延绪的水上书">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/16/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">HTML简明教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-16 15:37:49 / 修改时间：17:58:14" itemprop="dateCreated datePublished" datetime="2024-04-16T15:37:49+08:00">2024-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web-Development/" itemprop="url" rel="index"><span itemprop="name">Web Development</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2024/04/16/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2024/04/16/HTML简明教程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><blockquote>
<p>添加注释快捷键：<code>ctrl + /</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- DOCTYPE：告诉浏览器我们使用什么规范，省略亦可 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 写在html标签里的内容才会显示 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- meta：描述性标签，描述网页的一些信息，一般用来做SEO（搜索引擎优化） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">content</span>=<span class="string">&quot;HTML example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;This is an example of HTML&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的第一个HTML页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个简单的HTML页面。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;html&gt;</code>称为开放标签，<code>&lt;/html&gt;</code>称为闭合标签。</li>
<li><code>&lt;meta&gt; charset=&quot;UTF-8&quot;</code>称为自闭合标签。</li>
<li><code>title</code>是指浏览器顶部页眉方框所显示的，并不是页面内的标题。</li>
</ul>
<p><img src="/2024/04/16/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\HTML简明教程\helloworld.png" alt="hello world"></p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote>
<p>输入<code>p</code>并按<code>tab</code>键，会自动生成<code>&lt;p&gt;&lt;/p&gt;</code>标签。其余类似。</p>
</blockquote>
<h4 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h4><ul>
<li><code>&lt;h1&gt;&lt;/h1&gt;</code>：标题</li>
<li><code>&lt;p&gt;&lt;/p&gt;</code>：段落</li>
<li><code>&lt;hr&gt;</code>或<code>&lt;hr/&gt;</code>：水平线</li>
<li><code>&lt;br&gt;</code>：换行</li>
<li><code>&lt;b&gt;&lt;/b&gt;</code>或<code>&lt;strong&gt;&lt;/strong&gt;</code>：粗体</li>
<li><code>&lt;i&gt;&lt;/i&gt;</code>或<code>&lt;em&gt;&lt;/em&gt;</code>：斜体</li>
<li><code>&amp;...;</code>：转义字符（<code>&amp;</code>表示转义）</li>
<li><code>&amp;nbsp;</code>：空格</li>
<li><code>&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;</code>：图像</li>
</ul>
<blockquote>
<ol>
<li>空格键无论多少，都视为一个空格。多空格需用转义字符<code>&amp;nbsp</code>。</li>
<li>图像引用中<code>src</code>和<code>alt</code>必不可少。其余字段可以添加或省略。</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>基本标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标题标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>一首小诗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 段落标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not go gentle into that good night<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage, rage against the dying of the light<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 水平线 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 换行 --&gt;</span></span><br><span class="line">    两只老虎	两只老虎	跑得快 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    一只没有眼睛	一直没有尾巴 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    真奇怪		真奇怪 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 粗体与斜体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span> I love you. <span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span> I love you. <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span> I miss you. <span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span> I miss you. <span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 特殊符号 --&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 版权归延绪所有（版权符号） <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;lt;</span> <span class="symbol">&amp;gt;</span> <span class="symbol">&amp;amp;</span> <span class="symbol">&amp;quot;</span> <span class="symbol">&amp;nbsp;</span>（小于、大于、与、引号、空格） <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    空<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>格 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 图像标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../resources/images/SummerGhost3.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替代文字&quot;</span> <span class="attr">title</span>=<span class="string">&quot;悬停文字&quot;</span> <span class="attr">width</span>=<span class="string">&quot;960&quot;</span> <span class="attr">height</span>=<span class="string">&quot;540&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/16/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/Users\Keats\Desktop\Erewhon\Yanxu-Blog\source_posts\HTML简明教程\tags.png" alt="tags"></p>
<h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xht03</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xht03</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://book-written-on-water.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

    </div>
</body>
</html>
